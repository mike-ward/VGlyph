---
phase: 07-vertical-coords
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [layout.v, layout_types.v, _layout_test.v]
autonomous: true

must_haves:
  truths:
    - "Coordinate transform logic has inline formulas explaining what and why"
    - "All orientation enum values handled via match (compiler-verified)"
    - "Upright text path clearly separated from horizontal path via _upright/_horizontal functions"
    - "Coordinate system conventions documented at file top"
  artifacts:
    - path: "layout.v"
      provides: "Vertical text coordinate transforms"
      contains: "Coordinate Systems (vglyph conventions)"
    - path: "layout.v"
      provides: "Separated orientation functions"
      contains: "_vertical"
    - path: "layout.v"
      provides: "Helper functions for orientation dispatch"
      contains: ["compute_glyph_transform_horizontal", "compute_glyph_transform_vertical"]
    - path: "_layout_test.v"
      provides: "Orientation test coverage"
      contains: "test_vertical"
  key_links:
    - from: "layout.v:process_run"
      to: "compute_glyph_transform_horizontal/vertical"
      via: "match cfg.orientation dispatches to helper functions"
      pattern: "match.*orientation.*compute_glyph_transform"
    - from: "layout.v:layout_text"
      to: "init_vertical_pen_horizontal/vertical"
      via: "match cfg.orientation dispatches to helper functions"
      pattern: "match.*orientation.*init_vertical_pen"
---

<objective>
Document vertical text coordinate transforms and ensure exhaustive orientation handling.

Purpose: Make coordinate transforms clear (VERT-01), exhaustive (VERT-02), and distinguishable
(VERT-03). Completes v1.1 Fragile Area Hardening milestone.

Output: Inline transform docs, match expressions for orientation, explicit test cases.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-vertical-coords/07-CONTEXT.md
@.planning/phases/07-vertical-coords/07-RESEARCH.md
@layout.v
@layout_types.v
@_layout_test.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add coordinate system docs and transform formulas</name>
  <files>layout.v</files>
  <action>
  1. Add coordinate system conventions comment block near file top (after imports, before first fn):
     ```v
     // Coordinate Systems (vglyph conventions):
     // - Pango units: 1/PANGO_SCALE of a point (1024 units per point)
     // - Logical pixels: 1pt = 1px before DPI scaling
     // - Physical pixels: logical * scale_factor (for rasterization)
     // - Screen Y: Down is positive (standard graphics convention)
     // - Baseline Y: Up is positive (FreeType/typography convention)
     //
     // Vertical Text Flow:
     // - Characters stack top-to-bottom (pen moves DOWN)
     // - Each glyph centered horizontally in column
     // - Column width = line_height (ascent + descent)
     ```

  2. At process_run glyph loop (line ~637), add inline transform docs before the vertical block:
     ```v
     // Vertical Transform - Manual Stacking (Upright CJK)
     //
     // Input (from Pango horizontal layout):
     //   x_advance = character width (horizontal)
     //   y_offset  = vertical baseline shift
     //
     // Output (for vertical stacking):
     //   x_advance = 0 (no horizontal movement)
     //   y_advance = -line_height (negative = pen moves DOWN in screen coords)
     //   x_offset  = (line_height - char_width) / 2 (center in column)
     //
     // Formula: final_y_adv = -(ascent + descent)
     // Why: Screen Y increases downward, so negative advance moves pen down
     ```

  3. At process_run run positioning (line ~689), add inline transform docs:
     ```v
     // Vertical Run Positioning
     //
     // Transform: swap X/Y baselines
     //   final_run_x = run_y (horizontal baseline -> vertical X position)
     //   final_run_y = vertical_pen_y (cumulative vertical stack position)
     //
     // Why: In vertical text, the "baseline" becomes vertical center of column.
     // Pango's run_y (horizontal baseline offset) maps to X centering.
     ```

  4. At layout_text dimension override (line ~256), add inline doc:
     ```v
     // Vertical Dimensions Override
     //
     // Width = horizontal line_height (column width for vertical stack)
     // Height = cumulative vertical_pen_y (total stacked height)
     //
     // Why: Pango computed horizontal extents; we override with manual stack dimensions.
     ```
  </action>
  <verify>
  - `v -check-syntax layout.v` passes
  - `v fmt -w layout.v` runs without error
  - `v check-md -w .planning/phases/07-vertical-coords/07-01-PLAN.md 2>&1 || true`
  - grep shows "Coordinate Systems" comment in layout.v
  </verify>
  <done>
  Coordinate system conventions documented at file top. Transform formulas and rationale inline
  at each vertical transform site. VERT-01 satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract orientation helpers and convert to match dispatch</name>
  <files>layout.v</files>
  <action>
  Per CONTEXT.md locked decision: "Separate functions for upright vs rotated paths" with suffix
  naming `_horizontal()` / `_vertical()`. Extract orientation-specific logic into helper functions,
  then dispatch via match expressions for compiler-verified exhaustiveness.

  1. Create helper functions for vertical pen initialization:
     ```v
     // init_vertical_pen_horizontal returns initial vertical_pen_y for horizontal layout.
     // Horizontal text has no vertical pen tracking.
     fn init_vertical_pen_horizontal() f64 {
         return f64(0)
     }

     // init_vertical_pen_vertical returns initial vertical_pen_y for vertical layout.
     // Starts at primary ascent so first glyph baseline aligns properly.
     fn init_vertical_pen_vertical(primary_ascent f64) f64 {
         return primary_ascent
     }
     ```

  2. Create helper functions for glyph transform:
     ```v
     // compute_glyph_transform_horizontal returns glyph offsets/advances unchanged.
     // Horizontal text uses Pango values directly.
     fn compute_glyph_transform_horizontal(x_off f64, y_off f64, x_adv f64, y_adv f64) (f64, f64, f64, f64) {
         return x_off, y_off, x_adv, y_adv
     }

     // compute_glyph_transform_vertical transforms glyph for vertical stacking.
     // Centers glyph horizontally in column, sets vertical advance to line_height.
     fn compute_glyph_transform_vertical(x_off f64, y_off f64, x_adv f64, y_adv f64, line_height f64) (f64, f64, f64, f64) {
         // Vertical Transform - Manual Stacking (Upright CJK)
         // x_offset = center glyph in column: (line_height - char_width) / 2
         // y_offset = preserve vertical baseline shift
         // x_advance = 0 (no horizontal movement)
         // y_advance = -line_height (pen moves DOWN in screen coords)
         center_offset := (line_height - x_adv) / 2.0
         return center_offset, y_off, 0.0, -line_height
     }
     ```

  3. Create helper functions for run positioning:
     ```v
     // compute_run_position_horizontal returns run position for horizontal text.
     // Uses Pango coordinates directly.
     fn compute_run_position_horizontal(run_x f64, run_y f64, vertical_pen_y f64) (f64, f64, f64) {
         return run_x, run_y, vertical_pen_y
     }

     // compute_run_position_vertical transforms run position for vertical stacking.
     // Swaps X/Y baselines and updates vertical pen position.
     fn compute_run_position_vertical(run_x f64, run_y f64, vertical_pen_y f64, line_height f64, glyph_count int) (f64, f64, f64) {
         // Vertical Run Positioning: swap X/Y baselines
         // final_run_x = run_y (horizontal baseline -> vertical X position)
         // final_run_y = vertical_pen_y (cumulative vertical stack position)
         new_pen_y := vertical_pen_y + line_height * f64(glyph_count)
         return run_y, vertical_pen_y, new_pen_y
     }
     ```

  4. Create helper functions for dimension override:
     ```v
     // compute_dimensions_horizontal returns layout dimensions for horizontal text.
     // Uses Pango ink rect directly.
     fn compute_dimensions_horizontal(ink_width f32, ink_height f32, pango_scale f32, scale_factor f32) (f32, f32) {
         return (ink_width / pango_scale) / scale_factor, (ink_height / pango_scale) / scale_factor
     }

     // compute_dimensions_vertical returns layout dimensions for vertical text.
     // Width = line_height (column), Height = cumulative vertical pen position.
     fn compute_dimensions_vertical(line_height f32, vertical_pen_y f32) (f32, f32) {
         return line_height, vertical_pen_y
     }
     ```

  5. Replace if-statements with match dispatch at each site:

     At layout_text vertical_pen_y init:
     ```v
     vertical_pen_y := match cfg.orientation {
         .horizontal { init_vertical_pen_horizontal() }
         .vertical { init_vertical_pen_vertical(primary_ascent) }
     }
     ```

     At process_run glyph transforms:
     ```v
     line_height := cfg.primary_ascent + cfg.primary_descent
     final_x_off, final_y_off, final_x_adv, final_y_adv := match cfg.orientation {
         .horizontal { compute_glyph_transform_horizontal(x_off, y_off, x_adv, y_adv) }
         .vertical { compute_glyph_transform_vertical(x_off, y_off, x_adv, y_adv, line_height) }
     }
     ```

     At process_run run positioning:
     ```v
     final_run_x, final_run_y, new_vertical_pen_y := match cfg.orientation {
         .horizontal { compute_run_position_horizontal(run_x, run_y, vertical_pen_y) }
         .vertical { compute_run_position_vertical(run_x, run_y, vertical_pen_y, line_height, glyph_count) }
     }
     vertical_pen_y = new_vertical_pen_y
     ```

     At layout_text dimension override:
     ```v
     v_width, v_height := match cfg.orientation {
         .horizontal { compute_dimensions_horizontal(f32(ink_rect.width), f32(ink_rect.height), f32(pango_scale), scale_factor) }
         .vertical { compute_dimensions_vertical(l_height, f32(vertical_pen_y)) }
     }
     ```

  Note: Match dispatch ensures compiler-verified exhaustiveness (VERT-02), while separate helper
  functions provide branch clarity (CONTEXT.md decision). Document dispatch criteria at each
  calling site explaining what triggers each path.
  </action>
  <verify>
  - `v -check-syntax layout.v` passes
  - `v fmt -w layout.v` runs without error
  - grep shows "match cfg.orientation" (no remaining `if cfg.orientation`)
  - grep shows "compute_glyph_transform_horizontal" and "compute_glyph_transform_vertical"
  - grep shows "compute_run_position_horizontal" and "compute_run_position_vertical"
  - `v test .` passes existing tests
  </verify>
  <done>
  All orientation dispatch uses match expressions calling separate helper functions. Compiler
  will error if new TextOrientation variant added. Branch clarity maintained via extracted
  _horizontal/_vertical functions per CONTEXT.md decision. VERT-02 satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add explicit orientation test cases</name>
  <files>_layout_test.v</files>
  <action>
  Add test cases verifying both horizontal and vertical orientation paths work correctly.

  1. Add test for vertical layout dimensions:
     ```v
     fn test_vertical_layout_dimensions() {
         mut ctx := create_test_context()!
         defer { ctx.destroy() }

         // Vertical layout should have width < height for stacked text
         layout := ctx.layout_text('ABC', TextConfig{
             style: TextStyle{ font_name: 'Sans 12' }
             orientation: .vertical
         })
         defer { layout.destroy() }

         // For 3 chars stacked vertically:
         // - visual_width ~ line_height (column width)
         // - visual_height ~ 3 * line_height
         assert layout.visual_height > layout.visual_width,
             'vertical text should be taller than wide'
         assert layout.visual_height > 0, 'vertical layout has height'
         assert layout.visual_width > 0, 'vertical layout has width'
     }
     ```

  2. Add test for horizontal layout (regression guard):
     ```v
     fn test_horizontal_layout_dimensions() {
         mut ctx := create_test_context()!
         defer { ctx.destroy() }

         layout := ctx.layout_text('ABC', TextConfig{
             style: TextStyle{ font_name: 'Sans 12' }
             orientation: .horizontal
         })
         defer { layout.destroy() }

         // Horizontal text should be wider than tall (single line)
         assert layout.visual_width > layout.visual_height,
             'horizontal text should be wider than tall'
     }
     ```

  3. Add test for vertical glyph advances:
     ```v
     fn test_vertical_glyph_advances() {
         mut ctx := create_test_context()!
         defer { ctx.destroy() }

         layout := ctx.layout_text('AB', TextConfig{
             style: TextStyle{ font_name: 'Sans 12' }
             orientation: .vertical
         })
         defer { layout.destroy() }

         // Vertical glyphs should have y_advance (not x_advance)
         if layout.glyphs.len >= 2 {
             glyph := layout.glyphs[0]
             assert glyph.x_advance == 0, 'vertical glyph has no x_advance'
             assert glyph.y_advance != 0, 'vertical glyph has y_advance'
         }
     }
     ```

  Adapt test helper creation based on existing _layout_test.v patterns. If no test context
  helper exists, create minimal one or use vglyph.create_context() directly.
  </action>
  <verify>
  - `v test _layout_test.v` passes
  - `v test .` passes all tests
  - grep shows "test_vertical" and "test_horizontal" in _layout_test.v
  </verify>
  <done>
  Explicit test cases cover both orientation paths. Regression guard ensures horizontal still
  works after refactoring. VERT-03 partially satisfied (distinction is clear via tests + code).
  </done>
</task>

</tasks>

<verification>
Run after all tasks complete:

```bash
# Syntax and format
v -check-syntax layout.v
v fmt -w layout.v

# All tests pass
v test .

# Verify no if-based orientation checks remain (all converted to match)
grep -n "if.*orientation.*==" layout.v && echo "FAIL: if-based checks remain" || echo "PASS"

# Verify coordinate docs exist
grep -q "Coordinate Systems" layout.v && echo "PASS: coord docs" || echo "FAIL"

# Verify match expressions exist
grep -q "match.*orientation" layout.v && echo "PASS: match exprs" || echo "FAIL"

# Verify helper functions exist (CONTEXT.md: separate functions for orientation paths)
grep -q "compute_glyph_transform_horizontal" layout.v && echo "PASS: horizontal helper" || echo "FAIL"
grep -q "compute_glyph_transform_vertical" layout.v && echo "PASS: vertical helper" || echo "FAIL"

# Verify tests exist
grep -q "test_vertical" _layout_test.v && echo "PASS: tests" || echo "FAIL"
```
</verification>

<success_criteria>
1. Coordinate system conventions documented at layout.v file top
2. Each vertical transform site has inline formula + rationale
3. Helper functions extracted: `_horizontal()` / `_vertical()` suffixes per CONTEXT.md decision
4. All 4 orientation if-statements converted to match expressions dispatching to helpers
5. Adding new TextOrientation variant causes compile error until all matches updated
6. Test cases for both horizontal and vertical orientations pass
7. `v test .` passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/07-vertical-coords/07-01-SUMMARY.md`
</output>
