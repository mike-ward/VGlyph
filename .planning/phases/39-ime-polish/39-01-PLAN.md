---
phase: 39-ime-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [composition.v, api.v]
autonomous: true
must_haves:
  truths:
    - "CompositionState and DeadKeyState have consistent reset() methods"
    - "IME input strings are validated against max length and UTF-8"
    - "api.v IME wrappers are null-safe for Context and Renderer"
  artifacts:
    - path: "composition.v"
      provides: "State management and validation for IME"
    - path: "api.v"
      provides: "Safe IME API wrappers"
---

<objective>
Improve the V-side implementation of IME state management and security.
This plan adds RAII-consistent reset methods and enforces input validation for all IME-provided text.
</objective>

<execution_context>
@/Users/mike/.agent/workflows/execute-plan.md
</execution_context>

<context>
@.planning/phases/39-ime-polish/39-CONTEXT.md
@composition.v
@api.v
@validation.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add consistent reset methods to IME state</name>
  <files>composition.v</files>
  <action>
    Modify `CompositionState`:
    - Add `pub fn (mut cs CompositionState) reset()` that zeros all fields (phase = .none, preedit_text = '', etc.).
    - Update `commit()` and `cancel()` to call `reset()` for the reset part of their logic.
    
    Modify `DeadKeyState`:
    - Add `pub fn (mut dks DeadKeyState) reset()` that sets pending to none and pending_pos to 0.
    - Update `clear()` to call `reset()`.
  </action>
  <verify>
    Check that both structs have `reset()` and it is used by their cleanup methods.
  </verify>
  <done>
    Both structs have consistent `reset()` methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enforce input validation for IME strings</name>
  <files>composition.v</files>
  <action>
    In `composition.v`:
    - Modify `handle_marked_text` to call `validate_text_input(text, max_text_length, @FN) or { return }`.
    - Modify `handle_insert_text` to call `validate_text_input(text, max_text_length, @FN) or { return text }` (if invalid, we might still want to return the text to the caller, but if it's unsafe we should probably return empty string). Let's return empty string if invalid for `handle_insert_text`.
    - Ensure `handle_clause` validates `start` and `length` are non-negative.
  </action>
  <verify>
    Ensure `validate_text_input` is called in both handlers.
  </verify>
  <done>
    IME strings are validated before being processed into internal state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Audit api.v for null safety in IME functions</name>
  <files>api.v</files>
  <action>
    - Ensure `draw_composition` checks `ts.renderer != unsafe { nil }` (already does).
    - Add checks for `ts.ctx != unsafe { nil }` if any IME method uses the context.
    - Review other IME-related wrappers in `api.v` (if any) for similar checks.
  </action>
  <verify>
    Verify all `TextSystem` methods related to IME have null checks for `ctx` and `renderer`.
  </verify>
  <done>
    IME wrappers in `api.v` are null-safe.
  </done>
</task>

</tasks>

<verification>
Check `composition.v` and `api.v` for the implemented changes.
Run existing tests to ensure no regressions: `v test .`
</verification>

<success_criteria>
1. CompositionState and DeadKeyState have `reset()` methods.
2. `handle_marked_text` and `handle_insert_text` perform input validation.
3. `api.v` has been audited for null safety.
</success_criteria>

<output>
After completion, create `.planning/phases/39-ime-polish/39-01-SUMMARY.md`
</output>
