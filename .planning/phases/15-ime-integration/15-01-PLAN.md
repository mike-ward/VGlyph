---
phase: 15-ime-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [composition.v]
autonomous: true

must_haves:
  truths:
    - "CompositionState tracks preedit text, cursor position within preedit, and clause segments"
    - "DeadKeyState tracks pending dead key and combines with next character"
    - "Composition bounds API returns rect covering entire preedit for candidate window"
  artifacts:
    - path: "composition.v"
      provides: "CompositionState, DeadKeyState, Clause types"
      exports: ["CompositionState", "DeadKeyState", "Clause", "ClauseStyle", "CompositionPhase"]
  key_links:
    - from: "composition.v"
      to: "layout_query.v"
      via: "get_selection_rects for composition bounds"
      pattern: "get_selection_rects"
---

<objective>
Create VGlyph composition state types for IME integration.

Purpose: Provide data structures to track IME composition lifecycle (preedit text, cursor within
preedit, clause segments for multi-segment CJK input) and dead key sequences for accent input.

Output: composition.v with CompositionState, DeadKeyState, and related types.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-ime-integration/15-CONTEXT.md
@.planning/phases/15-ime-integration/15-RESEARCH.md
@layout_query.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CompositionState and DeadKeyState types</name>
  <files>composition.v</files>
  <action>
Create composition.v with IME composition state management:

```v
module vglyph

// CompositionPhase tracks IME composition lifecycle
pub enum CompositionPhase {
    none        // No active composition
    composing   // Preedit text being edited
}

// ClauseStyle differentiates underline thickness for multi-clause IME
pub enum ClauseStyle {
    raw       // Unconverted input (thin underline)
    converted // Converted text (thin underline)
    selected  // Currently selected for conversion (thick underline)
}

// Clause represents a segment in multi-clause CJK composition
pub struct Clause {
pub:
    start  int        // Byte offset within preedit_text
    length int        // Byte length of clause
    style  ClauseStyle
}

// CompositionState tracks IME composition for preedit display and candidate positioning.
// Per CONTEXT.md decisions:
// - Single underline for preedit (thick for selected clause)
// - Cursor visible inside composition for navigation
// - Focus loss: auto-commit; Escape: cancel; Click outside: commit then move
pub struct CompositionState {
pub mut:
    phase           CompositionPhase
    preedit_text    string     // Current composition string
    preedit_start   int        // Byte offset in document where preedit inserted
    cursor_offset   int        // Cursor position within preedit (0 = start)
    clauses         []Clause   // Segment info for multi-segment CJK input
    selected_clause int        // Currently selected clause index (-1 if none)
}

// is_composing returns true if composition is active
pub fn (cs &CompositionState) is_composing() bool {
    return cs.phase == .composing
}

// start begins composition at document cursor position
pub fn (mut cs CompositionState) start(cursor_pos int) {
    cs.phase = .composing
    cs.preedit_start = cursor_pos
    cs.preedit_text = ''
    cs.cursor_offset = 0
    cs.clauses.clear()
    cs.selected_clause = -1
}

// set_marked_text updates preedit from IME (called by native bridge).
// cursor_in_preedit is byte offset within preedit where cursor should be.
pub fn (mut cs CompositionState) set_marked_text(text string, cursor_in_preedit int) {
    cs.preedit_text = text
    cs.cursor_offset = cursor_in_preedit
}

// set_clauses updates clause segmentation from IME attributes
pub fn (mut cs CompositionState) set_clauses(clauses []Clause, selected int) {
    cs.clauses = clauses
    cs.selected_clause = selected
}

// commit finalizes composition, returns text to insert.
// Resets state to none phase.
pub fn (mut cs CompositionState) commit() string {
    result := cs.preedit_text
    cs.phase = .none
    cs.preedit_text = ''
    cs.preedit_start = 0
    cs.cursor_offset = 0
    cs.clauses.clear()
    cs.selected_clause = -1
    return result
}

// cancel discards composition without inserting text.
// Per CONTEXT.md: Escape cancels composition entirely.
pub fn (mut cs CompositionState) cancel() {
    cs.phase = .none
    cs.preedit_text = ''
    cs.preedit_start = 0
    cs.cursor_offset = 0
    cs.clauses.clear()
    cs.selected_clause = -1
}

// get_document_cursor_pos returns absolute cursor position in document.
// Used for cursor rendering during composition.
pub fn (cs &CompositionState) get_document_cursor_pos() int {
    return cs.preedit_start + cs.cursor_offset
}

// get_preedit_end returns byte offset where preedit ends in document
pub fn (cs &CompositionState) get_preedit_end() int {
    return cs.preedit_start + cs.preedit_text.len
}

// DeadKeyState tracks pending dead key for accent composition.
// Per CONTEXT.md decisions:
// - Show dead key as placeholder with underline
// - Invalid combination inserts both separately
// - Escape cancels pending dead key
pub struct DeadKeyState {
pub mut:
    pending     ?rune  // Dead key waiting for combination (none if not pending)
    pending_pos int    // Document position where dead key was typed
}

// has_pending returns true if dead key is waiting for combination
pub fn (dks &DeadKeyState) has_pending() bool {
    return dks.pending != none
}

// start_dead_key records a dead key press
pub fn (mut dks DeadKeyState) start_dead_key(dead rune, pos int) {
    dks.pending = dead
    dks.pending_pos = pos
}

// clear cancels pending dead key (Escape)
pub fn (mut dks DeadKeyState) clear() {
    dks.pending = none
    dks.pending_pos = 0
}

// try_combine attempts to combine pending dead key with base character.
// Returns (result_string, was_combined):
// - If combined successfully: ("e", true) for ` + e
// - If invalid combination: ("`x", false) for ` + x (inserts both)
// - If no pending: ("", false)
pub fn (mut dks DeadKeyState) try_combine(base rune) (string, bool) {
    dead := dks.pending or { return '', false }
    dks.pending = none
    dks.pending_pos = 0

    if combined := combine_dead_key(dead, base) {
        return rune_to_str(combined), true
    }
    // Invalid combination: insert both per CONTEXT.md
    return rune_to_str(dead) + rune_to_str(base), false
}

// is_dead_key returns true if rune is a dead key (accent starter)
pub fn is_dead_key(r rune) bool {
    return r in [`\``, `'`, `^`, `~`, `"`, `:`, `,`]
}

// combine_dead_key returns combined character or none if invalid
fn combine_dead_key(dead rune, base rune) ?rune {
    // Grave accent combinations
    if dead == `\`` {
        match base {
            `a` { return `a` }  // a with grave: U+00E0
            `e` { return `e` }  // e with grave: U+00E8
            `i` { return `i` }  // i with grave: U+00EC
            `o` { return `o` }  // o with grave: U+00F2
            `u` { return `u` }  // u with grave: U+00F9
            `A` { return `A` }  // A with grave: U+00C0
            `E` { return `E` }  // E with grave: U+00C8
            `I` { return `I` }  // I with grave: U+00CC
            `O` { return `O` }  // O with grave: U+00D2
            `U` { return `U` }  // U with grave: U+00D9
            else {}
        }
    }
    // Acute accent combinations
    if dead == `'` {
        match base {
            `a` { return `a` }  // a with acute: U+00E1
            `e` { return `e` }  // e with acute: U+00E9
            `i` { return `i` }  // i with acute: U+00ED
            `o` { return `o` }  // o with acute: U+00F3
            `u` { return `u` }  // u with acute: U+00FA
            `A` { return `A` }  // A with acute: U+00C1
            `E` { return `E` }  // E with acute: U+00C9
            `I` { return `I` }  // I with acute: U+00CD
            `O` { return `O` }  // O with acute: U+00D3
            `U` { return `U` }  // U with acute: U+00DA
            else {}
        }
    }
    // Circumflex combinations
    if dead == `^` {
        match base {
            `a` { return `a` }  // a with circumflex: U+00E2
            `e` { return `e` }  // e with circumflex: U+00EA
            `i` { return `i` }  // i with circumflex: U+00EE
            `o` { return `o` }  // o with circumflex: U+00F4
            `u` { return `u` }  // u with circumflex: U+00FB
            `A` { return `A` }  // A with circumflex: U+00C2
            `E` { return `E` }  // E with circumflex: U+00CA
            `I` { return `I` }  // I with circumflex: U+00CE
            `O` { return `O` }  // O with circumflex: U+00D4
            `U` { return `U` }  // U with circumflex: U+00DB
            else {}
        }
    }
    // Tilde combinations
    if dead == `~` {
        match base {
            `a` { return `a` }  // a with tilde: U+00E3
            `n` { return `n` }  // n with tilde: U+00F1
            `o` { return `o` }  // o with tilde: U+00F5
            `A` { return `A` }  // A with tilde: U+00C3
            `N` { return `N` }  // N with tilde: U+00D1
            `O` { return `O` }  // O with tilde: U+00D5
            else {}
        }
    }
    // Diaeresis (umlaut) combinations
    if dead == `"` || dead == `:` {
        match base {
            `a` { return `a` }  // a with diaeresis: U+00E4
            `e` { return `e` }  // e with diaeresis: U+00EB
            `i` { return `i` }  // i with diaeresis: U+00EF
            `o` { return `o` }  // o with diaeresis: U+00F6
            `u` { return `u` }  // u with diaeresis: U+00FC
            `y` { return `y` }  // y with diaeresis: U+00FF
            `A` { return `A` }  // A with diaeresis: U+00C4
            `E` { return `E` }  // E with diaeresis: U+00CB
            `I` { return `I` }  // I with diaeresis: U+00CF
            `O` { return `O` }  // O with diaeresis: U+00D6
            `U` { return `U` }  // U with diaeresis: U+00DC
            else {}
        }
    }
    // Cedilla combinations
    if dead == `,` {
        match base {
            `c` { return `c` }  // c with cedilla: U+00E7
            `C` { return `C` }  // C with cedilla: U+00C7
            else {}
        }
    }
    return none
}

// rune_to_str converts rune to string
fn rune_to_str(r rune) string {
    return [u8(r)].bytestr()
}
```

Note: The actual Unicode codepoints for accented characters need proper UTF-8 encoding. The
placeholders above show intent; fix the actual codepoints in implementation.
  </action>
  <verify>v -check-syntax composition.v && v fmt -w composition.v</verify>
  <done>CompositionState and DeadKeyState types compile, provide start/commit/cancel lifecycle</done>
</task>

<task type="auto">
  <name>Task 2: Add composition bounds API for candidate window positioning</name>
  <files>composition.v</files>
  <action>
Add method to CompositionState that returns composition bounds using Layout:

```v
// get_composition_bounds returns bounding rect covering entire preedit text.
// Per CONTEXT.md: "API reports full composition bounds (rect covering entire preedit)"
// Used by native bridge for firstRectForCharacterRange to position candidate window.
// Returns none if not composing.
pub fn (cs &CompositionState) get_composition_bounds(layout Layout) ?gg.Rect {
    if !cs.is_composing() || cs.preedit_text.len == 0 {
        return none
    }

    preedit_end := cs.get_preedit_end()
    rects := layout.get_selection_rects(cs.preedit_start, preedit_end)

    if rects.len == 0 {
        return none
    }

    // Return bounding rect of all selection rects
    mut min_x := f32(1e9)
    mut min_y := f32(1e9)
    mut max_x := f32(-1e9)
    mut max_y := f32(-1e9)

    for r in rects {
        if r.x < min_x { min_x = r.x }
        if r.y < min_y { min_y = r.y }
        if r.x + r.width > max_x { max_x = r.x + r.width }
        if r.y + r.height > max_y { max_y = r.y + r.height }
    }

    return gg.Rect{
        x:      min_x
        y:      min_y
        width:  max_x - min_x
        height: max_y - min_y
    }
}

// get_clause_rects returns selection rects for each clause (for underline rendering).
// Returns array of (clause_index, rects) pairs.
pub fn (cs &CompositionState) get_clause_rects(layout Layout) []struct {
    clause_idx int
    rects      []gg.Rect
    style      ClauseStyle
} {
    mut result := []struct {
        clause_idx int
        rects      []gg.Rect
        style      ClauseStyle
    }{}

    if !cs.is_composing() {
        return result
    }

    // If no explicit clauses, treat entire preedit as single raw clause
    if cs.clauses.len == 0 && cs.preedit_text.len > 0 {
        rects := layout.get_selection_rects(cs.preedit_start, cs.get_preedit_end())
        if rects.len > 0 {
            result << struct {
                clause_idx: 0
                rects:      rects
                style:      .raw
            }
        }
        return result
    }

    for i, clause in cs.clauses {
        clause_start := cs.preedit_start + clause.start
        clause_end := clause_start + clause.length
        rects := layout.get_selection_rects(clause_start, clause_end)
        if rects.len > 0 {
            result << struct {
                clause_idx: i
                rects:      rects
                style:      clause.style
            }
        }
    }

    return result
}
```

Add import for gg at top of file:
```v
import gg
```
  </action>
  <verify>v -check-syntax composition.v && v fmt -w composition.v</verify>
  <done>get_composition_bounds returns layout-relative rect for IME candidate positioning</done>
</task>

</tasks>

<verification>
- `v -check-syntax composition.v` passes
- `v fmt -w composition.v` produces no errors
- CompositionState has start/commit/cancel lifecycle methods
- DeadKeyState has try_combine for dead key sequences
- get_composition_bounds uses layout.get_selection_rects
</verification>

<success_criteria>
1. composition.v compiles without errors
2. CompositionState tracks preedit_text, cursor_offset, clauses
3. DeadKeyState handles dead key combination with try_combine
4. get_composition_bounds returns gg.Rect for candidate window positioning
5. Code follows VGlyph conventions (pub struct, pub fn patterns)
</success_criteria>

<output>
After completion, create `.planning/phases/15-ime-integration/15-01-SUMMARY.md`
</output>
