---
phase: 15-ime-integration
plan: 03
type: execute
wave: 3
depends_on: [15-01, 15-02]
files_modified: [examples/editor_demo.v]
autonomous: false

must_haves:
  truths:
    - "Japanese IME composition displays with underline"
    - "Committed text inserts at cursor position"
    - "Candidate window appears near cursor"
    - "Dead key sequences produce accented characters"
  artifacts:
    - path: "examples/editor_demo.v"
      provides: "IME-enabled editor demo"
      contains: "CompositionState"
  key_links:
    - from: "examples/editor_demo.v"
      to: "composition.v"
      via: "CompositionState usage"
      pattern: "composition\\."
    - from: "examples/editor_demo.v"
      to: "c_bindings.v"
      via: "register_ime_callbacks"
      pattern: "register_ime_callbacks"
---

<objective>
Integrate IME support into editor demo and verify with Japanese input.

Purpose: Wire CompositionState and native bridge to editor demo, add preedit underline rendering,
handle IME callbacks, verify Japanese IME and dead key input work correctly.

Output: Updated editor_demo.v with full IME support, human verification of Japanese input.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-ime-integration/15-CONTEXT.md
@.planning/phases/15-ime-integration/15-01-SUMMARY.md
@.planning/phases/15-ime-integration/15-02-SUMMARY.md
@examples/editor_demo.v
@composition.v
@c_bindings.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add composition state to EditorState and register IME callbacks</name>
  <files>examples/editor_demo.v</files>
  <action>
Update EditorState struct to include composition and dead key state. Register IME callbacks in
init function.

Add to EditorState struct:

```v
@[heap]
struct EditorState {
mut:
    // ... existing fields ...

    // IME composition state (Phase 15)
    composition vglyph.CompositionState
    dead_key    vglyph.DeadKeyState
}
```

In init function, register IME callbacks:

```v
fn init(state_ptr voidptr) {
    mut state := unsafe { &EditorState(state_ptr) }
    // ... existing init ...

    // Register IME callbacks
    vglyph.register_ime_callbacks(
        ime_set_marked_text,
        ime_insert_text,
        ime_unmark_text,
        ime_get_composition_rect,
        ime_has_marked_text,
        ime_get_marked_range,
        ime_get_selected_range
    )

    // Set text rendering offset for IME candidate window positioning
    C.vglyph_ime_set_text_offset(50, 50)  // offset_x, offset_y
}
```

Create IME callback functions (use global state pointer pattern):

```v
// Global state pointer for IME callbacks (set in init)
__global g_editor_state &EditorState = unsafe { nil }

fn ime_set_marked_text(text &char, text_len int, cursor_pos int) {
    if g_editor_state == unsafe { nil } { return }
    mut state := g_editor_state

    // Start composition if not already composing
    if !state.composition.is_composing() {
        state.composition.start(state.cursor_idx)
    }

    // Convert C string to V string
    preedit := unsafe { cstring_to_vstring(text) }
    state.composition.set_marked_text(preedit, cursor_pos)

    // Rebuild layout with preedit text inserted
    // The preedit is visual-only, not committed to state.text
    display_text := state.text[..state.composition.preedit_start] +
                    state.composition.preedit_text +
                    state.text[state.composition.preedit_start..]
    state.layout = state.ts.layout_text(display_text, state.cfg) or { return }
}

fn ime_insert_text(text &char, text_len int) {
    if g_editor_state == unsafe { nil } { return }
    mut state := g_editor_state

    // Commit any pending composition
    if state.composition.is_composing() {
        state.composition.commit()
    }

    // Insert the committed text
    insert_str := unsafe { cstring_to_vstring(text) }

    cursor_before := state.cursor_idx
    anchor_before := state.anchor_idx

    mut result := vglyph.MutationResult{}
    if state.has_selection {
        result = vglyph.insert_replacing_selection(state.text, state.cursor_idx,
            state.anchor_idx, insert_str)
    } else {
        result = vglyph.insert_text(state.text, state.cursor_idx, insert_str)
    }

    new_layout := state.ts.layout_text(result.new_text, state.cfg) or { return }

    state.text = result.new_text
    state.layout = new_layout
    state.cursor_idx = result.cursor_pos
    state.anchor_idx = result.cursor_pos
    state.has_selection = false

    // Track for undo
    state.undo_mgr.record_mutation(result, insert_str, cursor_before, anchor_before)
}

fn ime_unmark_text() {
    if g_editor_state == unsafe { nil } { return }
    mut state := g_editor_state

    // Per CONTEXT.md: Focus loss auto-commits
    if state.composition.is_composing() {
        commit_text := state.composition.commit()
        if commit_text.len > 0 {
            // Insert the committed text
            cursor_before := state.cursor_idx
            anchor_before := state.anchor_idx

            result := vglyph.insert_text(state.text, state.cursor_idx, commit_text)
            new_layout := state.ts.layout_text(result.new_text, state.cfg) or { return }

            state.text = result.new_text
            state.layout = new_layout
            state.cursor_idx = result.cursor_pos
            state.anchor_idx = result.cursor_pos
            state.has_selection = false

            state.undo_mgr.record_mutation(result, commit_text, cursor_before, anchor_before)
        }
    }
}

fn ime_get_composition_rect() (f32, f32, f32, f32) {
    if g_editor_state == unsafe { nil } { return 0, 0, 0, 0 }
    state := g_editor_state

    if rect := state.composition.get_composition_bounds(state.layout) {
        return rect.x, rect.y, rect.width, rect.height
    }
    // Fallback: cursor position
    if pos := state.layout.get_cursor_pos(state.cursor_idx) {
        return pos.x, pos.y, 2, pos.height
    }
    return 0, 0, 0, 0
}

fn ime_has_marked_text() bool {
    if g_editor_state == unsafe { nil } { return false }
    return g_editor_state.composition.is_composing()
}

fn ime_get_marked_range() (int, int) {
    if g_editor_state == unsafe { nil } { return -1, 0 }
    state := g_editor_state

    if !state.composition.is_composing() {
        return -1, 0  // NSNotFound equivalent
    }
    return state.composition.preedit_start, state.composition.preedit_text.len
}

fn ime_get_selected_range() (int, int) {
    if g_editor_state == unsafe { nil } { return 0, 0 }
    state := g_editor_state

    if state.has_selection {
        sel_start := if state.cursor_idx < state.anchor_idx { state.cursor_idx } else { state.anchor_idx }
        sel_len := if state.cursor_idx < state.anchor_idx { state.anchor_idx - state.cursor_idx } else { state.cursor_idx - state.anchor_idx }
        return sel_start, sel_len
    }
    return state.cursor_idx, 0
}

// C function declaration for setting text offset
fn C.vglyph_ime_set_text_offset(x f32, y f32)
```

In init, set global state pointer:

```v
g_editor_state = state
```
  </action>
  <verify>v -check-syntax examples/editor_demo.v</verify>
  <done>EditorState has composition state, IME callbacks registered</done>
</task>

<task type="auto">
  <name>Task 2: Add preedit underline rendering and dead key handling</name>
  <files>examples/editor_demo.v</files>
  <action>
Add preedit underline rendering in frame function. Add dead key handling in event function.

In frame function, after drawing text but before drawing cursor:

```v
fn frame(state_ptr voidptr) {
    mut state := unsafe { &EditorState(state_ptr) }
    // ... existing scroll and begin code ...

    offset_x := f32(50)
    offset_y := f32(50) - state.scroll_offset

    // Draw Selection Backgrounds (existing)
    // ...

    // Render the text using the system (existing)
    state.ts.draw_text(offset_x, offset_y, state.text, state.cfg) or { println(err) }

    // Draw preedit underlines if composing (NEW)
    if state.composition.is_composing() {
        draw_composition_underlines(state, offset_x, offset_y)
    }

    // Draw dead key placeholder if pending (NEW)
    if state.dead_key.has_pending() {
        draw_dead_key_placeholder(state, offset_x, offset_y)
    }

    // Draw Cursor (existing)
    // ...
}

// Draw underlines for composition text per CONTEXT.md:
// - Single underline for preedit
// - Thick underline for selected clause, thin for others
fn draw_composition_underlines(state &EditorState, offset_x f32, offset_y f32) {
    clause_rects := state.composition.get_clause_rects(state.layout)

    for cr in clause_rects {
        // Per CONTEXT.md: thick for selected, thin for others
        thickness := if cr.clause_idx == state.composition.selected_clause { 2.0 } else { 1.0 }

        for rect in cr.rects {
            // Draw underline at bottom of text
            state.gg_ctx.draw_rect_filled(
                offset_x + rect.x,
                offset_y + rect.y + rect.height - thickness,
                rect.width,
                thickness,
                state.cfg.style.color  // Same color as text per CONTEXT.md
            )
        }
    }
}

// Draw dead key as placeholder with underline per CONTEXT.md
fn draw_dead_key_placeholder(state &EditorState, offset_x f32, offset_y f32) {
    if dead := state.dead_key.pending {
        if pos := state.layout.get_cursor_pos(state.dead_key.pending_pos) {
            // Draw the dead key character as placeholder
            placeholder := vglyph.rune_to_str(dead)
            // Use small offset to show placeholder at cursor
            state.ts.draw_text(offset_x + pos.x, offset_y + pos.y, placeholder, state.cfg) or {}

            // Draw thin underline (same styling as preedit)
            // Get rough width estimate (single char ~8-12px)
            char_width := f32(10)
            state.gg_ctx.draw_rect_filled(
                offset_x + pos.x,
                offset_y + pos.y + pos.height - 1,
                char_width,
                1.0,
                state.cfg.style.color
            )
        }
    }
}
```

In event function, add dead key handling and composition escape:

```v
.key_down {
    // ... existing cmd+z handling ...

    // Per CONTEXT.md: Escape cancels composition entirely
    if e.key_code == .escape {
        if state.composition.is_composing() {
            state.composition.cancel()
            // Rebuild layout without preedit
            state.layout = state.ts.layout_text(state.text, state.cfg) or { return }
            return
        }
        // Per CONTEXT.md: Escape also cancels pending dead key
        if state.dead_key.has_pending() {
            state.dead_key.clear()
            return
        }
    }

    // ... rest of existing key handling ...
}

.char {
    // Skip if during IME composition (IME handles input)
    if state.composition.is_composing() {
        return
    }

    // ... existing skip and cmd checks ...

    // Dead key handling (before normal char input)
    char_rune := rune(e.char_code)
    if vglyph.is_dead_key(char_rune) && !state.dead_key.has_pending() {
        // Start dead key sequence
        state.dead_key.start_dead_key(char_rune, state.cursor_idx)
        return
    }

    // Try to combine with pending dead key
    if state.dead_key.has_pending() {
        combined, _ := state.dead_key.try_combine(char_rune)
        if combined.len > 0 {
            // Insert the combined result
            cursor_before := state.cursor_idx
            anchor_before := state.anchor_idx

            mut result := vglyph.MutationResult{}
            if state.has_selection {
                result = vglyph.insert_replacing_selection(state.text, state.cursor_idx,
                    state.anchor_idx, combined)
            } else {
                result = vglyph.insert_text(state.text, state.cursor_idx, combined)
            }

            new_layout := state.ts.layout_text(result.new_text, state.cfg) or { return }

            state.text = result.new_text
            state.layout = new_layout
            state.cursor_idx = result.cursor_pos
            state.anchor_idx = result.cursor_pos
            state.has_selection = false

            state.undo_mgr.record_mutation(result, combined, cursor_before, anchor_before)
            return
        }
    }

    // ... existing normal char input ...
}

.mouse_down {
    // Per CONTEXT.md: Click outside preedit commits then moves cursor
    if state.composition.is_composing() {
        commit_text := state.composition.commit()
        if commit_text.len > 0 {
            cursor_before := state.cursor_idx
            anchor_before := state.anchor_idx

            result := vglyph.insert_text(state.text, state.cursor_idx, commit_text)
            new_layout := state.ts.layout_text(result.new_text, state.cfg) or { return }

            state.text = result.new_text
            state.layout = new_layout
            state.cursor_idx = result.cursor_pos
            state.anchor_idx = result.cursor_pos

            state.undo_mgr.record_mutation(result, commit_text, cursor_before, anchor_before)
        }
    }
    // Continue with normal mouse handling...
}

.focus_out {
    // Per CONTEXT.md: Focus loss auto-commits
    if state.composition.is_composing() {
        commit_text := state.composition.commit()
        if commit_text.len > 0 {
            cursor_before := state.cursor_idx
            anchor_before := state.anchor_idx

            result := vglyph.insert_text(state.text, state.cursor_idx, commit_text)
            new_layout := state.ts.layout_text(result.new_text, state.cfg) or { return }

            state.text = result.new_text
            state.layout = new_layout
            state.cursor_idx = result.cursor_pos
            state.anchor_idx = result.cursor_pos

            state.undo_mgr.record_mutation(result, commit_text, cursor_before, anchor_before)
        }
    }
}
```
  </action>
  <verify>v -check-syntax examples/editor_demo.v && v fmt -w examples/editor_demo.v</verify>
  <done>Preedit underlines render, dead key handling works, composition lifecycle honored</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>IME integration: composition state, native bridge, editor demo wiring</what-built>
  <how-to-verify>
1. Run editor demo: `v run examples/editor_demo.v`
2. Switch to Japanese IME (Cmd+Space or System Preferences > Keyboard > Input Sources)
3. Type hiragana: "nihongo" should show にほんご with underline
4. Press Space to convert: candidate window should appear near text
5. Press Enter to commit: Japanese text appears in editor
6. Test dead keys: Type ` then e, should produce e
7. Test Escape during composition: should cancel without inserting
8. Test click during composition: should commit then move cursor
  </how-to-verify>
  <resume-signal>Type "approved" if Japanese IME and dead keys work, or describe issues</resume-signal>
</task>

</tasks>

<verification>
- `v run examples/editor_demo.v` starts without errors
- Japanese IME composition shows underlined preedit text
- Candidate window appears near cursor during composition
- Committed text inserts correctly
- Dead key sequences (` + e = e) work
- Escape cancels composition
- Click outside preedit commits
</verification>

<success_criteria>
1. Japanese IME typing shows composition with underline (IME-01)
2. Converted text replaces preedit at cursor (IME-02)
3. Candidate window appears near cursor (IME-03)
4. Dead key sequences produce accented characters (IME-04)
5. All CONTEXT.md behaviors honored (Escape cancels, click commits, focus loss commits)
</success_criteria>

<output>
After completion, create `.planning/phases/15-ime-integration/15-03-SUMMARY.md`
</output>
