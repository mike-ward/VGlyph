---
phase: 15-ime-integration
plan: 02
type: execute
wave: 2
depends_on: [15-01]
files_modified: [ime_bridge_macos.m, c_bindings.v]
autonomous: true

must_haves:
  truths:
    - "Native bridge implements NSTextInputClient protocol methods"
    - "setMarkedText forwards preedit to VGlyph CompositionState"
    - "insertText commits composition and inserts final text"
    - "firstRectForCharacterRange returns screen coordinates for candidate window"
  artifacts:
    - path: "ime_bridge_macos.m"
      provides: "NSTextInputClient protocol implementation"
      contains: "setMarkedText"
    - path: "c_bindings.v"
      provides: "V callbacks for IME bridge"
      contains: "ime_"
  key_links:
    - from: "ime_bridge_macos.m"
      to: "c_bindings.v"
      via: "C callback functions"
      pattern: "vglyph_ime_"
---

<objective>
Create native macOS bridge for IME support via NSTextInputClient protocol.

Purpose: Bridge between macOS text input system and VGlyph composition state. The native code
receives IME events (setMarkedText, insertText, unmarkText) and forwards them to V callbacks.
V code queries composition state to provide cursor geometry for candidate window positioning.

Output: ime_bridge_macos.m (Obj-C implementation), updates to c_bindings.v for callbacks.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-ime-integration/15-CONTEXT.md
@.planning/phases/15-ime-integration/15-RESEARCH.md
@composition.v
@c_bindings.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IME callback types and V-side interface</name>
  <files>c_bindings.v</files>
  <action>
Add IME callback function types and registration to c_bindings.v. The native bridge will call
these V functions when IME events occur.

Add to c_bindings.v:

```v
// IME callback function types for native bridge
// These are called from Obj-C when NSTextInputClient methods fire

// Called when IME updates preedit/marked text
// text: UTF-8 preedit string
// cursor_pos: cursor position within preedit (byte offset)
pub type ImeSetMarkedTextFn = fn (text &char, text_len int, cursor_pos int)

// Called when IME commits final text (user pressed Enter or selected candidate)
// text: UTF-8 committed string
pub type ImeInsertTextFn = fn (text &char, text_len int)

// Called when IME wants to commit current preedit as-is (focus loss, etc)
pub type ImeUnmarkTextFn = fn ()

// Called by native bridge to query composition rectangle for candidate window
// Returns: x, y, width, height in layout-relative coordinates
// Native bridge converts to screen coordinates
pub type ImeGetCompositionRectFn = fn () (f32, f32, f32, f32)

// Called by native bridge to query if composition is active
pub type ImeHasMarkedTextFn = fn () bool

// Called by native bridge to query marked text range
// Returns: start byte offset, length
pub type ImeGetMarkedRangeFn = fn () (int, int)

// Called by native bridge to query selection range
// Returns: start byte offset, length
pub type ImeGetSelectedRangeFn = fn () (int, int)

// Global IME callback storage (set by application)
__global (
    g_ime_set_marked_text    ImeSetMarkedTextFn
    g_ime_insert_text        ImeInsertTextFn
    g_ime_unmark_text        ImeUnmarkTextFn
    g_ime_get_composition_rect ImeGetCompositionRectFn
    g_ime_has_marked_text    ImeHasMarkedTextFn
    g_ime_get_marked_range   ImeGetMarkedRangeFn
    g_ime_get_selected_range ImeGetSelectedRangeFn
)

// register_ime_callbacks sets application callbacks for IME events.
// Must be called before IME events can be processed.
pub fn register_ime_callbacks(
    set_marked_text ImeSetMarkedTextFn,
    insert_text ImeInsertTextFn,
    unmark_text ImeUnmarkTextFn,
    get_composition_rect ImeGetCompositionRectFn,
    has_marked_text ImeHasMarkedTextFn,
    get_marked_range ImeGetMarkedRangeFn,
    get_selected_range ImeGetSelectedRangeFn
) {
    g_ime_set_marked_text = set_marked_text
    g_ime_insert_text = insert_text
    g_ime_unmark_text = unmark_text
    g_ime_get_composition_rect = get_composition_rect
    g_ime_has_marked_text = has_marked_text
    g_ime_get_marked_range = get_marked_range
    g_ime_get_selected_range = get_selected_range
}

// C-callable wrappers for native bridge to invoke V callbacks
// These are exported with C calling convention

#[export: 'vglyph_ime_set_marked_text']
fn c_ime_set_marked_text(text &char, text_len int, cursor_pos int) {
    if g_ime_set_marked_text != unsafe { nil } {
        g_ime_set_marked_text(text, text_len, cursor_pos)
    }
}

#[export: 'vglyph_ime_insert_text']
fn c_ime_insert_text(text &char, text_len int) {
    if g_ime_insert_text != unsafe { nil } {
        g_ime_insert_text(text, text_len)
    }
}

#[export: 'vglyph_ime_unmark_text']
fn c_ime_unmark_text() {
    if g_ime_unmark_text != unsafe { nil } {
        g_ime_unmark_text()
    }
}

#[export: 'vglyph_ime_get_composition_rect']
fn c_ime_get_composition_rect(x &f32, y &f32, width &f32, height &f32) {
    if g_ime_get_composition_rect != unsafe { nil } {
        rx, ry, rw, rh := g_ime_get_composition_rect()
        unsafe {
            *x = rx
            *y = ry
            *width = rw
            *height = rh
        }
    }
}

#[export: 'vglyph_ime_has_marked_text']
fn c_ime_has_marked_text() bool {
    if g_ime_has_marked_text != unsafe { nil } {
        return g_ime_has_marked_text()
    }
    return false
}

#[export: 'vglyph_ime_get_marked_range']
fn c_ime_get_marked_range(start &int, length &int) {
    if g_ime_get_marked_range != unsafe { nil } {
        s, l := g_ime_get_marked_range()
        unsafe {
            *start = s
            *length = l
        }
    } else {
        unsafe {
            *start = -1  // NSNotFound equivalent
            *length = 0
        }
    }
}

#[export: 'vglyph_ime_get_selected_range']
fn c_ime_get_selected_range(start &int, length &int) {
    if g_ime_get_selected_range != unsafe { nil } {
        s, l := g_ime_get_selected_range()
        unsafe {
            *start = s
            *length = l
        }
    } else {
        unsafe {
            *start = 0
            *length = 0
        }
    }
}
```
  </action>
  <verify>v -check-syntax c_bindings.v</verify>
  <done>IME callback types defined, C-callable wrappers exported</done>
</task>

<task type="auto">
  <name>Task 2: Create native macOS IME bridge</name>
  <files>ime_bridge_macos.m</files>
  <action>
Create ime_bridge_macos.m with NSTextInputClient protocol category on sokol's view.

This file extends _sapp_macos_view to implement NSTextInputClient. The approach uses a category
to add protocol methods without modifying sokol_app.h directly.

```objc
// ime_bridge_macos.m
// IME bridge for VGlyph - implements NSTextInputClient protocol
// Compile with: -fobjc-arc

#import <Cocoa/Cocoa.h>
#import <AppKit/AppKit.h>

// Forward declarations for V callback functions
extern void vglyph_ime_set_marked_text(const char* text, int text_len, int cursor_pos);
extern void vglyph_ime_insert_text(const char* text, int text_len);
extern void vglyph_ime_unmark_text(void);
extern void vglyph_ime_get_composition_rect(float* x, float* y, float* width, float* height);
extern _Bool vglyph_ime_has_marked_text(void);
extern void vglyph_ime_get_marked_range(int* start, int* length);
extern void vglyph_ime_get_selected_range(int* start, int* length);

// External: offset where text is rendered in view (set by app)
static float g_text_offset_x = 0;
static float g_text_offset_y = 0;

void vglyph_ime_set_text_offset(float x, float y) {
    g_text_offset_x = x;
    g_text_offset_y = y;
}

// Get sokol's view class name at runtime to add category
// Sokol uses _sapp_macos_view which inherits from MTKView or NSOpenGLView

@interface NSView (VGlyphIME) <NSTextInputClient>
@end

@implementation NSView (VGlyphIME)

// MARK: - NSTextInputClient Required Methods

- (void)insertText:(id)string replacementRange:(NSRange)replacementRange {
    NSString *text = [string isKindOfClass:[NSAttributedString class]]
        ? [(NSAttributedString*)string string]
        : string;

    const char *utf8 = [text UTF8String];
    int len = (int)[text lengthOfBytesUsingEncoding:NSUTF8StringEncoding];

    vglyph_ime_insert_text(utf8, len);
}

- (void)setMarkedText:(id)string
        selectedRange:(NSRange)selectedRange
     replacementRange:(NSRange)replacementRange {
    NSString *text = [string isKindOfClass:[NSAttributedString class]]
        ? [(NSAttributedString*)string string]
        : string;

    const char *utf8 = [text UTF8String];
    int len = (int)[text lengthOfBytesUsingEncoding:NSUTF8StringEncoding];

    // selectedRange.location is cursor position within preedit
    int cursor_pos = (int)selectedRange.location;

    vglyph_ime_set_marked_text(utf8, len, cursor_pos);
}

- (void)unmarkText {
    vglyph_ime_unmark_text();
}

- (NSRange)selectedRange {
    int start = 0, length = 0;
    vglyph_ime_get_selected_range(&start, &length);
    if (start < 0) {
        return NSMakeRange(NSNotFound, 0);
    }
    return NSMakeRange(start, length);
}

- (NSRange)markedRange {
    int start = 0, length = 0;
    vglyph_ime_get_marked_range(&start, &length);
    if (start < 0) {
        return NSMakeRange(NSNotFound, 0);
    }
    return NSMakeRange(start, length);
}

- (BOOL)hasMarkedText {
    return vglyph_ime_has_marked_text() ? YES : NO;
}

- (NSAttributedString *)attributedSubstringForProposedRange:(NSRange)range
                                                actualRange:(NSRangePointer)actualRange {
    // Return nil - we don't support this optional method
    // Per research: optional, can return nil
    return nil;
}

- (NSArray<NSAttributedStringKey> *)validAttributesForMarkedText {
    // Return empty array - we handle underline styling ourselves
    return @[];
}

- (NSRect)firstRectForCharacterRange:(NSRange)range
                         actualRange:(NSRangePointer)actualRange {
    // Get composition rect from VGlyph (layout-relative coordinates)
    float x = 0, y = 0, width = 0, height = 0;
    vglyph_ime_get_composition_rect(&x, &y, &width, &height);

    // Add text rendering offset
    NSRect viewRect = NSMakeRect(x + g_text_offset_x, y + g_text_offset_y, width, height);

    // Convert from view coordinates to window coordinates
    NSRect windowRect = [self convertRect:viewRect toView:nil];

    // Convert from window coordinates to screen coordinates
    // Per CONTEXT.md: "Let macOS handle screen-edge collision"
    NSRect screenRect = [[self window] convertRectToScreen:windowRect];

    // macOS uses bottom-left origin, flip Y for candidate window
    // The candidate window appears below the text, so use bottom of rect
    screenRect.origin.y -= screenRect.size.height;

    if (actualRange) {
        *actualRange = range;
    }

    return screenRect;
}

- (NSUInteger)characterIndexForPoint:(NSPoint)point {
    // Return 0 - optional method, not critical for basic IME
    return 0;
}

// MARK: - Override keyDown to route through input context

- (void)keyDown_withIME:(NSEvent *)event {
    // Let the input context handle the event first (for IME)
    // If it doesn't handle it, the event propagates normally
    NSTextInputContext *inputContext = [NSTextInputContext currentInputContext];
    if (inputContext) {
        [inputContext handleEvent:event];
    }
}

@end

// Initialize IME support - call this after window creation
void vglyph_ime_init(void) {
    // Force NSTextInputContext to recognize our view as text input client
    // This happens automatically when the view implements NSTextInputClient
    // No additional initialization needed
}
```

IMPORTANT: This approach uses a category on NSView which applies to all NSViews. A more targeted
approach would be to subclass sokol's view, but that requires modifying sokol_app.h. The category
approach is less invasive but may have side effects. Alternative: Create a separate overlay view
that acts as first responder for IME.

If the category approach causes issues, fall back to modifying v's sokol_app.h fork to add
NSTextInputClient conformance to _sapp_macos_view directly.
  </action>
  <verify>Test that file compiles: clang -c -fobjc-arc -framework Cocoa ime_bridge_macos.m -o /tmp/ime_test.o 2>&1 || echo "Compilation check - may fail without full linkage"</verify>
  <done>ime_bridge_macos.m implements NSTextInputClient protocol methods</done>
</task>

<task type="auto">
  <name>Task 3: Add build integration for native bridge</name>
  <files>v.mod</files>
  <action>
Check if vglyph uses v.mod for build configuration. If so, add the native .m file to sources.

If v.mod doesn't exist or doesn't support native sources, create a build note in the file header
of ime_bridge_macos.m explaining how to include it:

```
// Build integration:
// V automatically compiles .m files in the module directory on macOS.
// Ensure this file is in the vglyph module root alongside other .v files.
//
// If V doesn't auto-detect, add to compile command:
//   v -cflags "-fobjc-arc -framework Cocoa" run examples/editor_demo.v
//
// Or create a v.mod with:
//   Module {
//       name: 'vglyph'
//       ...
//   }
```

Check existing v.mod and add objc flags if needed. If no v.mod exists, the .m file in module
directory should be auto-compiled by V.
  </action>
  <verify>ls -la *.m v.mod 2>/dev/null; v -cflags "-fobjc-arc" -check-syntax examples/editor_demo.v 2>&1 | head -20</verify>
  <done>Build configuration includes native IME bridge</done>
</task>

</tasks>

<verification>
- c_bindings.v compiles with IME callback exports
- ime_bridge_macos.m compiles with clang (or V's C backend)
- V can link the module with native code included
- NSTextInputClient protocol methods implemented: insertText, setMarkedText, unmarkText, etc.
</verification>

<success_criteria>
1. IME callback types defined in c_bindings.v
2. C-callable wrappers exported with #[export: '...']
3. ime_bridge_macos.m implements all required NSTextInputClient methods
4. firstRectForCharacterRange converts to screen coordinates
5. Build integrates native .m file
</success_criteria>

<output>
After completion, create `.planning/phases/15-ime-integration/15-02-SUMMARY.md`
</output>
