---
phase: 12-selection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - examples/editor_demo.v
  - layout_query.v
autonomous: true

must_haves:
  truths:
    - "User clicks text, selection anchor set at click position"
    - "User drags mouse, text highlights from anchor to drag position"
    - "User releases mouse, selection persists"
    - "Auto-scroll occurs when dragging near text area edge"
    - "Option+drag snaps selection to word boundaries"
  artifacts:
    - path: "examples/editor_demo.v"
      provides: "Selection state management and click-drag implementation"
      contains: "anchor_idx"
    - path: "layout_query.v"
      provides: "Word boundary helpers for Option+drag"
      exports: ["get_word_at_index"]
  key_links:
    - from: "examples/editor_demo.v"
      to: "layout_query.v"
      via: "get_word_at_index for Option+drag"
      pattern: "get_word_at_index"
---

<objective>
Implement selection state management and mouse click-drag selection with auto-scroll.

Purpose: Enable visual text selection via mouse interaction - foundation for copy/cut operations.
Output: Working click-drag selection with highlight rendering, auto-scroll, and Option+drag word snap.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-selection/12-CONTEXT.md
@.planning/phases/12-selection/12-RESEARCH.md
@.planning/phases/11-cursor-foundation/11-02-SUMMARY.md
@layout_query.v
@layout_types.v
@examples/editor_demo.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add selection state and word boundary helper</name>
  <files>examples/editor_demo.v, layout_query.v</files>
  <action>
  In layout_query.v, add helper method:

  ```v
  // get_word_at_index returns (start, end) byte indices for word containing index.
  // Uses Pango word boundaries. Returns (index, index) if not in a word.
  pub fn (l Layout) get_word_at_index(byte_index int) (int, int)
  ```

  Implementation: Scan log_attr_by_index for is_word_start before index, is_word_end after.
  If click is on whitespace, snap to nearest word (scan both directions, pick closest boundary).

  In editor_demo.v EditorApp struct, update selection state fields:

  ```v
  // Selection state (anchor-focus model)
  anchor_idx    int  // Fixed point where selection started (-1 = no selection)
  is_dragging   bool // Mouse drag in progress
  has_selection bool // Selection currently active

  // Multi-click tracking (for Plan 02)
  last_click_time i64
  click_count     int

  // Auto-scroll state
  scroll_offset   f32  // Current vertical scroll offset
  scroll_velocity f32  // Pixels per frame when auto-scrolling
  ```

  Remove old `select_start` field, replace with `anchor_idx`.
  Initialize anchor_idx to -1 in main().
  </action>
  <verify>v -check-syntax layout_query.v && v -check-syntax examples/editor_demo.v</verify>
  <done>Selection state fields added, get_word_at_index method compiles</done>
</task>

<task type="auto">
  <name>Task 2: Implement click-drag selection with Option+drag word snap</name>
  <files>examples/editor_demo.v</files>
  <action>
  Update event() function mouse handling:

  **mouse_down:**
  - Get byte index from click position via get_closest_offset()
  - Check if Option/Alt held: `opt_held := (e.modifiers & u32(gg.Modifier.alt)) != 0`
  - If Option held: snap anchor_idx and cursor_idx to word boundaries using get_word_at_index()
  - Else: set anchor_idx = cursor_idx = clicked index
  - Set is_dragging = true, has_selection = false
  - Reset preferred_x = -1

  **mouse_move (when is_dragging):**
  - Get byte index at current mouse position
  - If Option held: snap to word boundaries (extend selection word-by-word)
  - Update cursor_idx to new position
  - Set has_selection = (anchor_idx != cursor_idx)
  - Do NOT clear anchor_idx (it stays fixed)

  **mouse_up:**
  - Set is_dragging = false
  - Keep has_selection if anchor_idx != cursor_idx

  **Key insight:** Anchor is fixed at initial click, cursor moves. Selection range is
  min(anchor, cursor) to max(anchor, cursor).

  Update frame() selection rendering:
  - Change condition from `select_start != -1 && cursor_idx != select_start`
    to `has_selection && anchor_idx != cursor_idx`
  - Use anchor_idx instead of select_start for get_selection_rects()
  - Keep existing blue highlight color (gg.Color{50, 50, 200, 100})
  </action>
  <verify>v run examples/editor_demo.v (manual: click and drag to select text)</verify>
  <done>Click-drag selection works, Option+drag snaps to words, highlight renders</done>
</task>

<task type="auto">
  <name>Task 3: Implement auto-scroll during drag</name>
  <files>examples/editor_demo.v</files>
  <action>
  Add auto-scroll when dragging near text area edges.

  Define constants at top:
  ```v
  const scroll_edge_threshold = 30  // Pixels from edge to trigger scroll
  const scroll_base_speed = 3.0     // Base pixels per frame
  const scroll_acceleration = 0.15  // Speed multiplier per pixel past threshold
  ```

  In mouse_move when is_dragging, after updating cursor_idx:

  Calculate distance past edge:
  ```v
  // Text area bounds (offset + layout height)
  text_top := offset_y
  text_bottom := offset_y + app.layout.height

  // Check if mouse is past edges
  if e.mouse_y < text_top + scroll_edge_threshold {
      // Above: scroll up
      dist := text_top + scroll_edge_threshold - e.mouse_y
      app.scroll_velocity = -scroll_base_speed - (dist * scroll_acceleration)
  } else if e.mouse_y > text_bottom - scroll_edge_threshold {
      // Below: scroll down
      dist := e.mouse_y - (text_bottom - scroll_edge_threshold)
      app.scroll_velocity = scroll_base_speed + (dist * scroll_acceleration)
  } else {
      app.scroll_velocity = 0
  }
  ```

  In frame(), before drawing:
  ```v
  // Apply auto-scroll
  if app.is_dragging && app.scroll_velocity != 0 {
      app.scroll_offset += app.scroll_velocity
      // Clamp to valid range
      max_scroll := app.layout.height - (window_height - 100)  // 100 = top+bottom margins
      if app.scroll_offset < 0 { app.scroll_offset = 0 }
      if max_scroll > 0 && app.scroll_offset > max_scroll {
          app.scroll_offset = max_scroll
      }
  }
  ```

  Apply scroll_offset to rendering:
  - Change offset_y in frame() to: `offset_y := f32(50) - app.scroll_offset`
  - Adjust mouse coordinates in event() by scroll_offset

  On mouse_up:
  - Reset scroll_velocity = 0
  </action>
  <verify>v run examples/editor_demo.v (manual: drag past bottom edge, verify scroll)</verify>
  <done>Auto-scroll works when dragging past text area edges, accelerates with distance</done>
</task>

</tasks>

<verification>
1. Build: `v examples/editor_demo.v` compiles without errors
2. Run: `./examples/editor_demo` launches without crash
3. Click-drag: Click text, drag to select, highlight appears
4. Option+drag: Hold Option, drag - selection snaps to word boundaries
5. Auto-scroll: With long text, drag past bottom edge - view scrolls down
6. Release: Selection persists after mouse release
</verification>

<success_criteria>
- Click anywhere sets cursor and anchor at same position
- Dragging creates visual highlight from anchor to cursor
- Option+drag selects whole words
- Releasing mouse keeps selection visible
- Auto-scroll activates when dragging past text area edge
- Scroll speed increases with distance from edge
</success_criteria>

<output>
After completion, create `.planning/phases/12-selection/12-01-SUMMARY.md`
</output>
