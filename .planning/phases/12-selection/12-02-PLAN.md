---
phase: 12-selection
plan: 02
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - examples/editor_demo.v
  - layout_query.v
autonomous: false

must_haves:
  truths:
    - "Shift+Arrow extends selection from anchor in movement direction"
    - "Arrow without Shift collapses selection (left->start, right->end)"
    - "Cmd+A selects all text"
    - "Double-click selects entire word"
    - "Triple-click selects entire paragraph"
    - "Click inside selection clears selection and repositions cursor"
  artifacts:
    - path: "examples/editor_demo.v"
      provides: "Keyboard selection and multi-click implementation"
      contains: "click_count"
    - path: "layout_query.v"
      provides: "Paragraph boundary helper"
      exports: ["get_paragraph_at_index"]
  key_links:
    - from: "examples/editor_demo.v"
      to: "layout_query.v"
      via: "get_paragraph_at_index for triple-click"
      pattern: "get_paragraph_at_index"
---

<objective>
Implement keyboard selection (Shift+arrows) and multi-click word/paragraph selection.

Purpose: Complete selection interaction model with standard editor behaviors.
Output: Full selection support including keyboard extension, collapse, Cmd+A, double/triple-click.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-selection/12-CONTEXT.md
@.planning/phases/12-selection/12-RESEARCH.md
@.planning/phases/12-selection/12-01-SUMMARY.md
@layout_query.v
@examples/editor_demo.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement keyboard selection with Shift modifier</name>
  <files>examples/editor_demo.v</files>
  <action>
  Update key_down handling in event() function.

  Check Shift modifier: `shift_held := (e.modifiers & u32(gg.Modifier.shift)) != 0`

  **When Shift held (selection extension):**
  - If no selection (!has_selection), set anchor_idx = cursor_idx first
  - Move cursor_idx using existing movement methods
  - Set has_selection = (anchor_idx != cursor_idx)
  - Do NOT reset anchor_idx

  **When Shift NOT held (collapse and move):**
  - If has_selection:
    - Left/Up: cursor_idx = min(anchor_idx, cursor_idx), then move
    - Right/Down: cursor_idx = max(anchor_idx, cursor_idx), then move
  - Clear selection: has_selection = false, anchor_idx = -1
  - Then apply normal cursor movement

  **Handle all navigation keys:**
  - `.left` / `.right` - character/word with Cmd
  - `.up` / `.down` - line with preferred_x
  - `.home` / `.end` - line start/end
  - Add Shift variants for all

  **Cmd+A (select all):**
  ```v
  .a {
      if cmd_held {
          app.anchor_idx = 0
          // Get last valid cursor position
          positions := app.layout.get_valid_cursor_positions()
          app.cursor_idx = if positions.len > 0 { positions[positions.len - 1] } else { 0 }
          app.has_selection = app.anchor_idx != app.cursor_idx
      }
  }
  ```

  Note: Cmd+Shift+Arrow for word selection should include trailing space (macOS convention).
  This is handled by move_cursor_word_right which already moves to next word start.
  </action>
  <verify>v -check-syntax examples/editor_demo.v</verify>
  <done>Shift+Arrow extends selection, Arrow collapses, Cmd+A selects all</done>
</task>

<task type="auto">
  <name>Task 2: Implement multi-click word/paragraph selection</name>
  <files>examples/editor_demo.v, layout_query.v</files>
  <action>
  In layout_query.v, add paragraph boundary helper:

  ```v
  // get_paragraph_at_index returns (start, end) byte indices for paragraph containing index.
  // Paragraph = text between empty lines (consecutive newlines).
  // Returns (0, text_len) if no empty lines found.
  pub fn (l Layout) get_paragraph_at_index(byte_index int, text string) (int, int)
  ```

  Implementation:
  - Scan backwards from byte_index for "\n\n" or start of text
  - Scan forwards from byte_index for "\n\n" or end of text
  - Return (para_start, para_end)

  In editor_demo.v, update mouse_down handling:

  **Multi-click detection:**
  ```v
  import time

  // In mouse_down handler:
  current_time := time.now().unix_milli()
  click_threshold := i64(400)  // Fixed 400ms per user decision

  if current_time - app.last_click_time < click_threshold {
      app.click_count += 1
  } else {
      app.click_count = 1
  }
  app.last_click_time = current_time
  ```

  **Handle click count:**
  ```v
  match app.click_count {
      1 {
          // Single click - normal anchor set (existing code)
          // Also: if clicking inside existing selection, clear and reposition
          if app.has_selection {
              sel_start := math.min(app.anchor_idx, app.cursor_idx)
              sel_end := math.max(app.anchor_idx, app.cursor_idx)
              if idx >= sel_start && idx < sel_end {
                  // Click inside selection - clear and reposition
                  app.has_selection = false
              }
          }
          app.anchor_idx = idx
          app.cursor_idx = idx
      }
      2 {
          // Double-click - select word
          start, end := app.layout.get_word_at_index(idx)
          app.anchor_idx = start
          app.cursor_idx = end
          app.has_selection = start != end
      }
      3 {
          // Triple-click - select paragraph
          start, end := app.layout.get_paragraph_at_index(idx, app.text)
          app.anchor_idx = start
          app.cursor_idx = end
          app.has_selection = start != end
          app.click_count = 0  // Reset to prevent quad-click
      }
      else {
          app.click_count = 1  // Reset if somehow > 3
      }
  }
  ```

  **Double-click on whitespace:**
  Per user decision: snap to adjacent word. get_word_at_index already handles this
  by scanning both directions and returning nearest word boundaries.
  </action>
  <verify>v run examples/editor_demo.v (manual: double-click word, triple-click paragraph)</verify>
  <done>Double-click selects word, triple-click selects paragraph, click inside clears</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Complete selection system:
  - Click-drag selection (Plan 01)
  - Option+drag word-by-word selection (Plan 01)
  - Auto-scroll during drag (Plan 01)
  - Shift+Arrow selection extension
  - Arrow collapse to selection edge
  - Cmd+A select all
  - Double-click word selection
  - Triple-click paragraph selection
  - Click inside selection clears it
  </what-built>
  <how-to-verify>
  1. Build and run: `v run examples/editor_demo.v`
  2. **Click-drag:** Click, hold, drag across text - blue highlight appears
  3. **Release:** Let go - selection stays
  4. **Option+drag:** Hold Option, click-drag - selection snaps to whole words
  5. **Shift+Right:** Press Shift+Right Arrow - selection extends right
  6. **Shift+Left:** Press Shift+Left Arrow - selection extends left
  7. **Right (collapse):** Press Right Arrow (no Shift) - cursor moves to right edge, selection clears
  8. **Left (collapse):** Select text, press Left Arrow - cursor moves to left edge, selection clears
  9. **Cmd+A:** Press Cmd+A - all text selected
  10. **Double-click:** Double-click on a word - entire word selects
  11. **Triple-click:** Triple-click on a line - entire paragraph selects
  12. **Click inside:** Select text, click inside selection - selection clears
  13. **Emoji selection:** Select across emoji - selection handles multi-byte chars correctly
  14. **Auto-scroll:** Add more text to make it scrollable, drag past bottom - scroll activates
  </how-to-verify>
  <resume-signal>Type "approved" or list specific issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. Build: `v examples/editor_demo.v` compiles without errors
2. All selection modes functional per checkpoint checklist
3. No crashes on edge cases (empty text, single character, start/end of text)
4. Selection state consistent across mode switches (mouse->keyboard->mouse)
</verification>

<success_criteria>
- Shift+Arrow extends selection in movement direction
- Arrow without Shift collapses selection to direction (left->start, right->end)
- Cmd+A selects all text from start to end
- Double-click selects word at click position
- Triple-click selects paragraph containing click position
- Click inside existing selection clears it and repositions cursor
- All selection modes work with emoji and multi-byte characters
</success_criteria>

<output>
After completion, create `.planning/phases/12-selection/12-02-SUMMARY.md`
</output>
