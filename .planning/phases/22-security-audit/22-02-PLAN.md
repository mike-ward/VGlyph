---
phase: 22-security-audit
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/vglyph/api.v
  - src/vglyph/context.v
  - src/vglyph/renderer.v
  - src/vglyph/glyph_atlas.v
  - src/vglyph/layout.v
autonomous: true

must_haves:
  truths:
    - "Null pointers in public APIs return error instead of crash"
    - "Memory allocations are checked before use"
    - "Allocation limits enforced consistently across codebase"
  artifacts:
    - path: "api.v"
      provides: "Null checks at TextSystem entry points"
      contains: "unsafe { nil }"
    - path: "glyph_atlas.v"
      provides: "Allocation checks before vcalloc use"
      contains: "check_allocation_size"
  key_links:
    - from: "renderer.v"
      to: "glyph_atlas.v"
      via: "new_glyph_atlas returns error type"
      pattern: "new_glyph_atlas.*!"
---

<objective>
Audit and harden null pointer handling in public APIs and verify memory allocation safety.

Purpose: Satisfy SEC-04 (allocation checks), SEC-05 (null pointer handling), SEC-06 (allocation
limits). Ensure no crashes from null inputs and no unhandled allocation failures.

Output: All public API entry points check for null/invalid pointers. Allocation paths verify success.
Consistent 1GB limit enforced (already exists in glyph_atlas.v, verify all paths use it).
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-security-audit/22-CONTEXT.md
@.planning/phases/22-security-audit/22-RESEARCH.md

# Source files to audit
@api.v
@context.v
@renderer.v
@glyph_atlas.v
@layout.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit and add null pointer checks in public APIs</name>
  <files>api.v, context.v, renderer.v</files>
  <action>
Audit all public functions (marked `pub fn`) for null pointer handling.

1. **api.v - TextSystem methods**:
   - `draw_text()`: Check `ts.ctx` and `ts.renderer` not nil at entry
   - `draw_layout()`: Check layout has valid items (empty is OK, nil is not)
   - `get_atlas_image()`: Already checks pages.len, verify safe
   - `add_font_file()`: Path validated in Plan 01, no pointer concerns
   - `layout_text()`: Propagates to context, check context not nil
   - All methods: Add guard `if ts.ctx == unsafe { nil } { return error(...) }`

2. **context.v - Context methods**:
   - `font_height()`: Check desc, font, metrics not nil (already has checks, verify errors not panics)
   - `font_metrics()`: Same pattern
   - `create_font_description()`: Returns nil on failure, callers must check
   - `free()`: Check each pointer before freeing (already does, verify)
   - Convert any `log.error` + `return 0` to `return error(...)` for consistency

3. **renderer.v - Renderer methods**:
   - `draw_layout()`: Check layout.items exists, check atlas.pages not empty
   - `get_or_load_glyph()`: Already checks `item.ft_face == unsafe { nil }`, verify returns error
   - `commit()`: Check atlas.pages not empty before iterating

Pattern for null checks:
```v
if ptr == unsafe { nil } {
    return error('Null ${name} at ${@FILE}:${@LINE}')
}
```

Do NOT add null checks inside hot loops (per-glyph iteration). Only at function entry for public APIs.
  </action>
  <verify>
`v -check-syntax api.v context.v renderer.v` passes.
Grep for `unsafe { nil }` to confirm null checks added.
  </verify>
  <done>
All public API entry points have null pointer guards that return errors with descriptive messages
including location. No crashes possible from null context/renderer/layout passed to public methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify allocation checks and consistent limits</name>
  <files>glyph_atlas.v, renderer.v, layout.v</files>
  <action>
Audit all memory allocation paths for proper error handling.

1. **glyph_atlas.v** - Already has `check_allocation_size()`:
   - Verify all `vcalloc()` calls check result is not nil
   - Verify all allocation paths use `check_allocation_size()` before allocating
   - Locations to check:
     - `new_atlas_page()`: Line ~119 vcalloc - already checks nil, verify
     - `grow_page()`: Line ~577 vcalloc - already checks nil, verify
     - `reset_page()`: No allocation, safe
   - Verify `max_allocation_size` constant (1GB) used consistently

2. **renderer.v**:
   - `new_glyph_atlas()` call: Already uses `!` return, verify panics are appropriate
   - The `or { panic(err) }` in new_renderer is per PROJECT.md decision (init failure = fatal)
   - Add comment explaining why panic is acceptable at init

3. **layout.v**:
   - No direct vcalloc/vmalloc calls (uses V arrays which handle allocation)
   - V arrays grow automatically with bounds checking
   - Verify no unbounded array growth that could exhaust memory:
     - `char_rects`: Bounded by text.len (capped at 10KB in Plan 01)
     - `items`: Bounded by number of runs (typically < 100)
     - `all_glyphs`: Bounded by text length * glyphs per char (~2x text.len max)
   - Add comment documenting these implicit bounds

4. **ft_bitmap_to_bitmap()** in glyph_atlas.v:
   - Already checks `out_length > max_i32 || out_length <= 0`
   - Verify emoji bitmap max 256x256 check (already exists line ~399)
   - Add constant `max_glyph_size = 256` and use it instead of magic number

Allocation limit summary (document in code comments):
- Atlas page: check_allocation_size() with 1GB limit
- Glyph bitmap: 256x256 max = 256KB max
- Text input: 10KB max (Plan 01)
- Total atlas memory: 4 pages * 4096*4096*4 = 256MB max
  </action>
  <verify>
`v -check-syntax glyph_atlas.v renderer.v layout.v` passes.
Grep for `vcalloc` and verify each has nil check.
Grep for allocation size checks.
  </verify>
  <done>
All vcalloc/vmalloc calls check for nil return. Allocation limits documented and consistent.
1GB max enforced. No unbounded memory growth possible.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add defensive nil checks at C FFI boundaries</name>
  <files>context.v, layout.v, glyph_atlas.v</files>
  <action>
Audit C FFI calls for null pointer returns and add defensive checks.

1. **context.v - FreeType/Pango calls**:
   - `C.FT_Init_FreeType()`: Already checks return code, good
   - `C.pango_ft2_font_map_new()`: Already checks nil, good
   - `C.pango_font_map_create_context()`: Already checks nil, good
   - `C.pango_context_load_font()`: Checks nil, good
   - `C.pango_ft2_font_get_face()`: Check returns - add nil check if missing
   - `C.pango_font_get_metrics()`: Already checks nil, good
   - `C.FcConfigGetCurrent()`: Already checks nil, good

2. **layout.v - Pango iterator calls**:
   - `C.pango_layout_get_iter()`: Already checks nil at line ~177, good
   - `C.pango_layout_iter_get_run_readonly()`: Can return nil (end of runs), handled
   - `C.pango_font_get_metrics()`: Already checks nil at line ~607, good
   - `C.pango_layout_get_log_attrs_readonly()`: Checks nil, good

3. **glyph_atlas.v - FreeType calls**:
   - `C.FT_Load_Glyph()`: Checks return code, returns error on failure
   - `C.FT_Render_Glyph()`: Checks return code, has fallback path
   - `ft_bitmap.buffer`: Checks for 0 at line ~272

4. **Pattern for C FFI null checks**:
```v
// Before accessing C pointer fields
face := C.pango_ft2_font_get_face(font)
if face == unsafe { nil } {
    return error('FreeType face unavailable at ${@FILE}:${@LINE}')
}
```

Focus on pointers that are dereferenced. Pointers only stored or passed through don't need immediate checks.
  </action>
  <verify>
`v -check-syntax context.v layout.v glyph_atlas.v` passes.
Review each C.* call for appropriate error handling.
  </verify>
  <done>
All C FFI calls that return pointers have nil checks before dereference. Errors include location
and context about which library call failed.
  </done>
</task>

</tasks>

<verification>
1. `v test .` - all tests pass
2. `v -check-syntax *.v` - no syntax errors
3. Grep for `vcalloc` shows all have nil checks
4. Grep for C library calls shows return value checks
5. No bare pointer dereferences without nil guards at public API boundaries
</verification>

<success_criteria>
1. Passing nil to public TextSystem methods returns error, not crash
2. All vcalloc calls check for nil and return error on failure
3. 1GB allocation limit enforced consistently (glyph_atlas.v check_allocation_size)
4. C library null returns handled with descriptive errors
5. All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-security-audit/22-02-SUMMARY.md`
</output>
