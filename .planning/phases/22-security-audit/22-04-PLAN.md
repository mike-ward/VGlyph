---
phase: 22-security-audit
plan: 04
type: execute
wave: 2
depends_on: ["22-01", "22-02"]
files_modified:
  - src/vglyph/context.v
  - src/vglyph/layout.v
  - src/vglyph/glyph_atlas.v
  - src/vglyph/renderer.v
  - src/vglyph/SECURITY.md
autonomous: true

must_haves:
  truths:
    - "FreeType handles freed on all exit paths"
    - "Pango objects freed on all exit paths"
    - "Atlas resources cleaned up on destroy"
    - "Security model documented in SECURITY.md"
  artifacts:
    - path: "context.v"
      provides: "FreeType cleanup with defer"
      contains: "defer { C.FT_Done"
    - path: "layout.v"
      provides: "Pango cleanup with defer"
      contains: "defer { C.g_object_unref"
    - path: "SECURITY.md"
      provides: "Security model documentation"
      contains: "Threat Model"
  key_links:
    - from: "context.v"
      to: "FreeType"
      via: "defer cleanup on error paths"
      pattern: "defer.*FT_Done"
    - from: "layout.v"
      to: "Pango"
      via: "defer cleanup for layouts and iterators"
      pattern: "defer.*g_object_unref"
---

<objective>
Verify resource cleanup on all exit paths and create security documentation.

Purpose: Satisfy SEC-09 (FreeType cleanup), SEC-10 (Pango cleanup), SEC-11 (atlas cleanup). Per
RESEARCH.md: "Use defer immediately after allocation" and CONTEXT.md: "Both in-code comments AND
separate SECURITY.md".

Output: All resource allocations have corresponding defer cleanup. SECURITY.md documents threat
model, validation rules, and resource lifecycle.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-security-audit/22-CONTEXT.md
@.planning/phases/22-security-audit/22-RESEARCH.md
@.planning/phases/22-security-audit/22-01-SUMMARY.md
@.planning/phases/22-security-audit/22-02-SUMMARY.md

# Source files to audit
@context.v
@layout.v
@glyph_atlas.v
@renderer.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit FreeType handle cleanup</name>
  <files>context.v, glyph_atlas.v</files>
  <action>
Verify all FreeType handles are freed on all exit paths (SEC-09).

1. **context.v - FT_Library lifecycle**:
   - `new_context()`: Creates ft_lib. On error paths, verify FT_Done_FreeType called.
   - Current code: Lines 156-175 have proper cleanup on error paths
   - Verify pattern:
     ```v
     if C.FT_Init_FreeType(&ft_lib) != 0 { return error(...) }
     // Later error:
     if pango_font_map == nil {
         C.FT_Done_FreeType(ft_lib)  // Must exist
         return error(...)
     }
     ```
   - `free()`: Calls FT_Done_FreeType on ft_lib. Verify nil check.

2. **glyph_atlas.v - FT_Face usage**:
   - `load_glyph()`: Uses cfg.face (borrowed from Pango, not owned). No cleanup needed.
   - `ft_bitmap_to_bitmap()`: Uses ft_face for family_name check only. No cleanup needed.
   - FT_Face is owned by Pango (pango_ft2_font_get_face returns borrowed pointer).
   - Add comment documenting this ownership: "// FT_Face borrowed from Pango, do not free"

3. **Check for FT allocations without cleanup**:
   ```bash
   grep -n "C.FT_" *.v | grep -v "Done\|Load\|Render\|Outline"
   ```
   - FT_Init_FreeType: Paired with FT_Done_FreeType in free()
   - FT_New_Face: Not used (Pango handles face loading)
   - FT_Set_Char_Size: Not used (Pango handles sizing)

4. **Add defer pattern if missing**:
   If any function creates FT resources and has multiple return paths, use:
   ```v
   ft_lib := C.FT_Init_FreeType(...)
   defer { C.FT_Done_FreeType(ft_lib) }
   ```
   But: new_context returns the ft_lib, so defer would be wrong there. Cleanup is in free().
   This is correct pattern for owned resources returned to caller.
  </action>
  <verify>
`v -check-syntax context.v glyph_atlas.v` passes.
Grep for FT_ calls and verify each has corresponding cleanup.
  </verify>
  <done>
All FreeType handles properly cleaned up. FT_Library freed in Context.free(). FT_Face ownership
documented (Pango-owned, not freed by VGlyph).
  </done>
</task>

<task type="auto">
  <name>Task 2: Audit Pango object cleanup</name>
  <files>context.v, layout.v</files>
  <action>
Verify all Pango objects are freed on all exit paths (SEC-10).

1. **context.v - Pango context/font map**:
   - `new_context()`: Creates pango_font_map, pango_context. Error paths clean up.
   - `free()`: Calls g_object_unref on both. Verify nil checks.
   - Current code looks correct, verify with read.

2. **layout.v - PangoLayout and iterators**:
   - `setup_pango_layout()`: Creates PangoLayout, returns it. Caller must free.
   - `layout_text()`: Calls setup_pango_layout, has `defer { C.g_object_unref(layout) }`. Good.
   - `layout_rich_text()`: Same pattern with defer. Good.
   - Verify defer is IMMEDIATELY after creation, not after other operations.

3. **layout.v - PangoLayoutIter**:
   - `build_layout_from_pango()`: Creates iter, has defer. Good.
   - `compute_hit_test_rects()`: Creates iter, has defer. Good.
   - `compute_lines()`: Creates line_iter, has defer. Good.
   - `extract_log_attrs()`: Creates iter, has defer. Good.

4. **layout.v - PangoAttrList**:
   - Already has tracking with `track_attr_list_alloc/free` in debug.
   - `setup_pango_layout()`: Creates attr_list, calls set_attributes, then unref. Good.
   - `layout_rich_text()`: Same pattern. Good.
   - `apply_rich_text_style()`: Inserts into list (list takes ownership). Good.
   - Verify comment: "Double-free prevented: unref called exactly once after set_attributes"

5. **PangoFontDescription**:
   - Created in multiple places. Verify each has free:
   - `create_font_description()`: Returns desc. Callers must free.
   - `font_height()`: Creates desc, has defer. Good.
   - `font_metrics()`: Creates desc, has defer. Good.
   - `setup_pango_layout()`: Creates desc, frees after set_font_description. Good.
   - `apply_rich_text_style()`: Creates desc, frees after attr creation. Good.

6. **PangoFontMetrics**:
   - `font_height()`: Gets metrics, has defer to unref. Good.
   - `font_metrics()`: Same. Good.
   - `get_run_metrics()`: Gets metrics, unrefs. Good.

Ensure defer is immediately after allocation:
```v
metrics := C.pango_font_get_metrics(font, language)
if metrics == unsafe { nil } { return error(...) }
defer { C.pango_font_metrics_unref(metrics) }
// ... use metrics ...
```
  </action>
  <verify>
`v -check-syntax context.v layout.v` passes.
Grep for Pango object creation and verify cleanup:
`grep -n "pango_layout_new\|pango_layout_get_iter\|pango_attr_list_new\|pango_font_description" *.v`
  </verify>
  <done>
All Pango objects properly cleaned up with defer statements. AttrList lifecycle documented with
ownership transfer comments. No leaks in error paths.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SECURITY.md documentation</name>
  <files>SECURITY.md</files>
  <action>
Create SECURITY.md in repository root documenting security model.

Structure:
```markdown
# VGlyph Security Model

## Threat Model

**Primary threat:** Untrusted text content from external sources.

VGlyph is a text rendering library that processes user-provided text. The main security
concerns are:

1. **Malformed input** - Invalid UTF-8, extreme sizes, malicious paths
2. **Resource exhaustion** - DoS through large text, many glyphs
3. **Memory corruption** - Buffer overflows, use-after-free in C libraries

## Input Validation

All public APIs validate input at entry:

| Input Type | Validation | Error Behavior |
|------------|------------|----------------|
| Text strings | UTF-8 encoding, max 10KB | Return error |
| Font paths | Existence, no traversal | Return error |
| Font size | Range [0.1, 500] | Clamp with warning |
| Dimensions | Positive, max 16384 | Return error |

## Resource Limits

| Resource | Limit | Enforcement |
|----------|-------|-------------|
| Text length | 10KB | validate_text_input() |
| Font size | 500pt max | validate_size() |
| Glyph bitmap | 256x256 | ft_bitmap_to_bitmap() |
| Atlas page | 4096x4096 | GlyphAtlas.max_height |
| Total atlas | 4 pages (~256MB) | GlyphAtlas.max_pages |
| Single alloc | 1GB | check_allocation_size() |

## Error Handling

- All errors include source location (file:line)
- C library errors wrapped with context
- No silent failures in public APIs
- V result types enforce error handling

## Resource Lifecycle

### FreeType
- FT_Library: Created in new_context(), freed in Context.free()
- FT_Face: Borrowed from Pango (not owned, do not free)

### Pango
- PangoLayout: Created per layout_text(), freed via defer
- PangoLayoutIter: Created per iteration, freed via defer
- PangoAttrList: Ownership transferred to layout, then unref'd
- PangoFontDescription: Freed after use with defer

### Atlas Memory
- Pages allocated via vcalloc with nil check
- Old textures queued for cleanup (garbage list)
- cleanup() called per frame to release old resources

## Debug Features

Enable debug builds (`v -d debug`) for additional checks:
- AttrList leak counter (check_attr_list_leaks())
- Iterator exhaustion detection
- Glyph cache collision detection
- FreeType state validation

## Known Limitations

1. **Korean IME first-keypress** - macOS-level bug, documented upstream
2. **Font format validation** - Delegated to FreeType
3. **Thread safety** - V is single-threaded by design

## Reporting Security Issues

Report security issues to: [repository issues with security label]
```
  </action>
  <verify>
SECURITY.md exists and passes `v check-md -w SECURITY.md`.
Content covers threat model, validation, limits, lifecycle.
  </verify>
  <done>
SECURITY.md documents complete security model including threat model, validation rules, resource
limits, cleanup lifecycle, and debug features. Serves as central reference for security decisions.
  </done>
</task>

</tasks>

<verification>
1. `v test .` - all tests pass
2. `v -check-syntax *.v` - no syntax errors
3. `v check-md -w SECURITY.md` - markdown valid
4. Grep for resource allocations shows all have cleanup
5. SECURITY.md covers all SEC-* requirements
</verification>

<success_criteria>
1. FreeType handles freed on all exit paths (verify Context.free, error paths)
2. Pango objects freed on all exit paths (verify defer patterns)
3. Atlas resources cleaned up via cleanup() and garbage collection
4. SECURITY.md exists with threat model, validation rules, resource limits
5. Inline comments document ownership for complex lifecycles
</success_criteria>

<output>
After completion, create `.planning/phases/22-security-audit/22-04-SUMMARY.md`
</output>
