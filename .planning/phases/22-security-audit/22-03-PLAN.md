---
phase: 22-security-audit
plan: 03
type: execute
wave: 2
depends_on: ["22-01", "22-02"]
files_modified:
  - src/vglyph/api.v
  - src/vglyph/context.v
  - src/vglyph/layout.v
  - src/vglyph/glyph_atlas.v
  - src/vglyph/renderer.v
autonomous: true

must_haves:
  truths:
    - "All error paths return proper errors (no silent failures)"
    - "Error types documented at function signatures"
    - "No log.error followed by silent return value"
  artifacts:
    - path: "api.v"
      provides: "Public API with documented error signatures"
      contains: "//! Returns error"
    - path: "context.v"
      provides: "Context methods with error documentation"
      contains: "@[return: error"
  key_links:
    - from: "api.v"
      to: "context.v"
      via: "Error propagation with !"
      pattern: "\\)!"
---

<objective>
Audit all error paths to ensure proper error returns (no silent failures) and document error types.

Purpose: Satisfy SEC-07 (proper error returns) and SEC-08 (error type documentation). Per CONTEXT.md:
"Error detail: Descriptive" and "All error paths return proper errors (no silent failures)".

Output: All functions that can fail return `!` type. Error conditions documented in comments.
No `log.error` + `return 0` or `return false` patterns remaining.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/22-security-audit/22-CONTEXT.md
@.planning/phases/22-security-audit/22-RESEARCH.md
@.planning/phases/22-security-audit/22-01-SUMMARY.md
@.planning/phases/22-security-audit/22-02-SUMMARY.md

# Source files to audit
@api.v
@context.v
@layout.v
@glyph_atlas.v
@renderer.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert silent failures to error returns</name>
  <files>api.v, context.v, layout.v, renderer.v</files>
  <action>
Find and convert all "log.error + silent return" patterns to proper error returns.

Search patterns to find:
```bash
grep -n "log.error" *.v
grep -n "return false" *.v
grep -n "return 0" *.v
grep -n "return TextMetrics{}" *.v
grep -n "return Layout{}" *.v
```

1. **context.v**:
   - `font_height()`: Returns 0 on error. Change to `!f32` and return error.
   - `font_metrics()`: Returns empty TextMetrics on error. Change to `!TextMetrics`.
   - `add_font_file()`: Returns false on error. Change to `!bool` or just `!` (no return value).
   - `resolve_font_name()`: Returns error string. Consider returning `!string` with actual error.
   - `create_font_description()`: Returns nil on failure. Keep as-is (internal, callers check).

2. **layout.v**:
   - `layout_text()`: Already returns `!Layout`, good.
   - `build_layout_from_pango()`: Returns empty Layout on iter nil. This is internal, but should
     propagate error. Change call site in layout_text to handle.
   - `parse_run_attributes()`: Returns defaults on bad data. OK for internal use.
   - `copy_bitmap_to_page()`: Uses log.error + return. Change to `!` return type.

3. **renderer.v**:
   - `get_or_load_glyph()`: Already returns `!CachedGlyph`, good.
   - `load_glyph()`: Already returns `!CachedGlyph`, good.

4. **glyph_atlas.v**:
   - `insert_bitmap()`: Already returns `!`, good.
   - `grow_page()`: Already returns `!`, good.
   - `ft_bitmap_to_bitmap()`: Already returns `!Bitmap`, good.

For each conversion:
- Change return type to include `!`
- Replace `log.error(...); return X` with `return error('...')`
- Update all call sites to use `!` propagation or `or { ... }` handling
- Keep error messages descriptive with `${@FILE}:${@LINE}`
  </action>
  <verify>
`v -check-syntax *.v` passes.
Grep for `log.error.*return` patterns - should find none (all converted).
  </verify>
  <done>
No silent failures remain. All error conditions return actual errors with descriptive messages.
Functions that previously returned sentinel values (0, false, empty struct) now return `!` types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Document error conditions at function signatures</name>
  <files>api.v, context.v, layout.v, glyph_atlas.v</files>
  <action>
Add error documentation to all public functions that return `!` type.

Documentation format (V doc comment style):
```v
// function_name does X.
//
// Returns error if:
// - condition A (e.g., "text is invalid UTF-8")
// - condition B (e.g., "font file does not exist")
pub fn function_name(...) ! {
```

1. **api.v - TextSystem public methods**:
   - `new_text_system()`: "FreeType/Pango initialization fails"
   - `draw_text()`: "text is invalid UTF-8, empty, or exceeds max length"
   - `text_width()`: same as draw_text
   - `text_height()`: same as draw_text
   - `layout_text()`: same as draw_text
   - `layout_text_cached()`: same as draw_text
   - `layout_rich_text()`: "any run text is invalid UTF-8"
   - `add_font_file()`: "path does not exist or contains traversal"

2. **context.v - Context public methods**:
   - `new_context()`: "FreeType init fails, Pango font map creation fails"
   - `font_height()`: "font description invalid, font load fails"
   - `font_metrics()`: same as font_height
   - `add_font_file()`: "path invalid, FcConfig unavailable"
   - `layout_text()`: "text empty, Pango layout creation fails"

3. **layout.v** - internal functions (brief docs):
   - `setup_pango_layout()`: "Pango layout creation fails"
   - `build_layout_from_pango()`: "iterator creation fails"

4. **glyph_atlas.v**:
   - `insert_bitmap()`: "glyph too large, allocation fails"
   - `grow_page()`: "allocation fails, exceeds max size"
   - `ft_bitmap_to_bitmap()`: "unsupported pixel mode, size overflow"

Use consistent format across all files.
  </action>
  <verify>
`v doc api.v` shows error conditions in generated docs.
Grep for "Returns error if" in public function comments.
  </verify>
  <done>
All public `!`-returning functions have doc comments listing error conditions. Developers can
understand what can fail without reading implementation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify error propagation chains are complete</name>
  <files>api.v, context.v, layout.v</files>
  <action>
Audit error propagation to ensure errors bubble up correctly.

1. **Check `!` propagation**:
   - Every internal `!` call should use `!` suffix to propagate
   - Example: `result := internal_func()!` (not `internal_func() or { return default }`)
   - Exception: When caller wants to handle error differently, use `or` block

2. **Check error wrapping**:
   - Per CONTEXT.md: "Library errors: Wrap with context"
   - Pattern: `result := c_call() or { return error('Context: ${err.msg()} at ${@FILE}:${@LINE}') }`
   - Ensure FreeType errors include error code: "FreeType error ${code} loading..."
   - Ensure Pango errors include function name: "pango_layout_new failed..."

3. **Verify call chains**:
   - `draw_text` -> `get_or_create_layout` -> `layout_text` -> `setup_pango_layout`
   - Each step should propagate errors
   - Verify with grep: `grep -n "layout_text\|get_or_create_layout\|setup_pango" api.v context.v layout.v`

4. **Check for swallowed errors**:
   - `or { continue }` in loops - OK if error is non-fatal for that item
   - `or { CachedGlyph{} }` in renderer - OK, fallback for missing glyph
   - `or { panic(err) }` - Only OK at init (per PROJECT.md decision)
   - Document any intentional error suppression with comment explaining why

Add error chain context where missing (per RESEARCH.md pattern):
```v
layout := setup_pango_layout(mut ctx, text, cfg) or {
    return error('layout_text: ${err.msg()}')
}
```
  </action>
  <verify>
`v -check-syntax *.v` passes.
Manual review of error propagation paths.
No unintentional `or { default }` patterns that hide errors.
  </verify>
  <done>
Error propagation is complete from C FFI layer through public API. Errors include context
(function name, parameter values) for debugging. No errors silently swallowed without documented
reason.
  </done>
</task>

</tasks>

<verification>
1. `v test .` - all tests pass
2. `v -check-syntax *.v` - no syntax errors
3. `grep -n "log.error.*return" *.v` - returns empty (no silent failures)
4. All public `!` functions have error documentation
5. Error messages include location (file:line) and context
</verification>

<success_criteria>
1. No `log.error()` followed by return of sentinel value (0, false, empty struct)
2. All public functions that can fail have `!` return type
3. All public `!` functions have doc comment listing error conditions
4. Error messages are descriptive: include what failed, why, and where
5. Errors propagate from C library layer through public API without loss
</success_criteria>

<output>
After completion, create `.planning/phases/22-security-audit/22-03-SUMMARY.md`
</output>
