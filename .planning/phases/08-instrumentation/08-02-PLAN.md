---
phase: 08-instrumentation
plan: 02
type: execute
wave: 2
depends_on: [08-01]
files_modified: [context.v, renderer.v, glyph_atlas.v]
autonomous: true

must_haves:
  truths:
    - "Cache hit/miss rates trackable for glyph cache"
    - "Atlas utilization shows used vs total pixels"
    - "Memory peak tracking shows growth"
    - "Developer can query metrics via get_profile_metrics()"
  artifacts:
    - path: "context.v"
      provides: "Extended ProfileMetrics with cache/atlas/memory fields"
      contains: "cache_hits"
    - path: "renderer.v"
      provides: "Glyph cache hit/miss tracking and API exposure"
      pattern: "get_profile_metrics"
    - path: "glyph_atlas.v"
      provides: "Atlas utilization and memory tracking"
      pattern: "atlas_used_pixels"
  key_links:
    - from: "renderer.v"
      to: "context.v"
      via: "ProfileMetrics aggregation from atlas"
      pattern: "profile_metrics"
    - from: "glyph_atlas.v"
      to: "renderer.v"
      via: "Atlas metrics passed to renderer"
      pattern: "atlas_inserts"
---

<objective>
Add cache statistics, atlas utilization, and memory tracking to ProfileMetrics. Expose public API
for querying metrics.

Purpose: Enable developers to analyze cache efficiency, atlas memory usage, and identify
optimization opportunities.

Output: Complete ProfileMetrics with all INST fields, public get_profile_metrics() API.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-instrumentation/08-RESEARCH.md
@.planning/phases/08-instrumentation/08-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ProfileMetrics with cache/atlas/memory fields</name>
  <files>context.v</files>
  <action>
Extend ProfileMetrics struct (from Plan 01) with additional fields:

```v
$if profile ? {
    pub struct ProfileMetrics {
    pub mut:
        // Frame timing (nanoseconds) - from Plan 01
        layout_time_ns     i64
        rasterize_time_ns  i64
        upload_time_ns     i64
        draw_time_ns       i64

        // Cache statistics (INST-03)
        glyph_cache_hits   int
        glyph_cache_misses int

        // Atlas statistics (INST-05)
        atlas_inserts       int
        atlas_grows         int
        atlas_resets        int
        atlas_used_pixels   i64
        atlas_total_pixels  i64

        // Memory tracking (INST-04)
        peak_atlas_bytes    i64
        current_atlas_bytes i64
    }

    // Derived metrics
    pub fn (m ProfileMetrics) cache_hit_rate() f32 {
        total := m.glyph_cache_hits + m.glyph_cache_misses
        if total == 0 { return 0.0 }
        return f32(m.glyph_cache_hits) / f32(total) * 100.0
    }

    pub fn (m ProfileMetrics) atlas_utilization() f32 {
        if m.atlas_total_pixels == 0 { return 0.0 }
        return f32(m.atlas_used_pixels) / f32(m.atlas_total_pixels) * 100.0
    }

    pub fn (m ProfileMetrics) print_summary() {
        total_ns := m.layout_time_ns + m.rasterize_time_ns + m.upload_time_ns + m.draw_time_ns
        println('=== VGlyph Profile Metrics ===')
        println('Frame Time Breakdown:')
        println('  Layout:    ${m.layout_time_ns / 1000} us')
        println('  Rasterize: ${m.rasterize_time_ns / 1000} us')
        println('  Upload:    ${m.upload_time_ns / 1000} us')
        println('  Draw:      ${m.draw_time_ns / 1000} us')
        println('  Total:     ${total_ns / 1000} us')
        println('Cache: ${m.cache_hit_rate():.1}% hit rate (${m.glyph_cache_hits}/${m.glyph_cache_hits + m.glyph_cache_misses})')
        println('Atlas: ${m.atlas_utilization():.1}% utilized (${m.atlas_used_pixels}/${m.atlas_total_pixels} px)')
        println('Memory: ${m.current_atlas_bytes / 1024} KB current, ${m.peak_atlas_bytes / 1024} KB peak')
    }
}
```
  </action>
  <verify>Run `v -d profile -check-syntax context.v` - no errors</verify>
  <done>ProfileMetrics has all INST-03/04/05 fields plus derived metric functions</done>
</task>

<task type="auto">
  <name>Task 2: Add cache and atlas tracking to renderer and glyph_atlas</name>
  <files>renderer.v, glyph_atlas.v</files>
  <action>
**renderer.v - Track glyph cache hits/misses in get_or_load_glyph():**
```v
fn (mut renderer Renderer) get_or_load_glyph(item Item, glyph Glyph, bin int) !CachedGlyph {
    // ... key calculation ...

    if key in renderer.cache {
        $if profile ? {
            renderer.glyph_cache_hits++
        }
        return renderer.cache[key]
    }

    $if profile ? {
        renderer.glyph_cache_misses++
    }

    // ... load glyph ...
}
```

Add cache tracking fields to Renderer struct (extend existing $if profile ? block):
```v
$if profile ? {
    pub mut:
        rasterize_time_ns  i64
        upload_time_ns     i64
        draw_time_ns       i64
        glyph_cache_hits   int
        glyph_cache_misses int
}
```

**glyph_atlas.v - Track atlas operations in insert_bitmap() and grow():**

In insert_bitmap():
```v
pub fn (mut atlas GlyphAtlas) insert_bitmap(bmp Bitmap, left int, top int) !(CachedGlyph, bool) {
    $if profile ? {
        atlas.atlas_inserts++
    }

    // ... existing reset logic ...
    if atlas.height >= atlas.max_height {
        $if profile ? {
            atlas.atlas_resets++
        }
        // ... reset code ...
    }

    // ... rest of function ...
}
```

In grow():
```v
pub fn (mut atlas GlyphAtlas) grow(new_height int) ! {
    $if profile ? {
        atlas.atlas_grows++
    }
    // ... existing code ...

    // After allocation, update memory tracking
    $if profile ? {
        atlas.current_atlas_bytes = new_size
        if new_size > atlas.peak_atlas_bytes {
            atlas.peak_atlas_bytes = new_size
        }
    }
}
```

Add profile fields to GlyphAtlas struct:
```v
pub struct GlyphAtlas {
    // ... existing fields ...
    $if profile ? {
        pub mut:
            atlas_inserts       int
            atlas_grows         int
            atlas_resets        int
            current_atlas_bytes i64
            peak_atlas_bytes    i64
    }
}
```

Initialize peak_atlas_bytes in new_glyph_atlas():
```v
$if profile ? {
    atlas.current_atlas_bytes = size
    atlas.peak_atlas_bytes = size
}
```
  </action>
  <verify>
Run `v -d profile -check-syntax renderer.v glyph_atlas.v` - no errors.
Run `v -check-syntax renderer.v glyph_atlas.v` (release) - no errors.
  </verify>
  <done>Cache hits/misses tracked, atlas inserts/grows/resets tracked, memory bytes tracked</done>
</task>

<task type="auto">
  <name>Task 3: Expose public get_profile_metrics() API</name>
  <files>renderer.v</files>
  <action>
Add public API to Renderer for querying aggregated metrics:

```v
$if profile ? {
    // get_profile_metrics returns aggregated profiling metrics.
    // Combines Renderer timing/cache stats with GlyphAtlas memory stats.
    pub fn (renderer &Renderer) get_profile_metrics() ProfileMetrics {
        // Calculate atlas utilization
        used_pixels := i64(renderer.atlas.cursor_y + renderer.atlas.row_height) * i64(renderer.atlas.width)
        total_pixels := i64(renderer.atlas.width) * i64(renderer.atlas.height)

        return ProfileMetrics{
            // Timing from Renderer
            rasterize_time_ns: renderer.rasterize_time_ns
            upload_time_ns:    renderer.upload_time_ns
            draw_time_ns:      renderer.draw_time_ns

            // Cache from Renderer
            glyph_cache_hits:   renderer.glyph_cache_hits
            glyph_cache_misses: renderer.glyph_cache_misses

            // Atlas from GlyphAtlas
            atlas_inserts:      renderer.atlas.atlas_inserts
            atlas_grows:        renderer.atlas.atlas_grows
            atlas_resets:       renderer.atlas.atlas_resets
            atlas_used_pixels:  used_pixels
            atlas_total_pixels: total_pixels

            // Memory from GlyphAtlas
            current_atlas_bytes: renderer.atlas.current_atlas_bytes
            peak_atlas_bytes:    renderer.atlas.peak_atlas_bytes
        }
    }

    // reset_profile_metrics clears all profiling counters.
    pub fn (mut renderer Renderer) reset_profile_metrics() {
        renderer.rasterize_time_ns = 0
        renderer.upload_time_ns = 0
        renderer.draw_time_ns = 0
        renderer.glyph_cache_hits = 0
        renderer.glyph_cache_misses = 0
        // Note: Don't reset atlas counters - they represent lifetime stats
    }
}
```

Note: Layout timing is on Context, not Renderer. User aggregates both:
- `ctx.profile_metrics.layout_time_ns` for layout timing
- `renderer.get_profile_metrics()` for render/cache/atlas metrics

Run v fmt -w on all modified files.
  </action>
  <verify>
Run `v -d profile -check-syntax renderer.v` - no errors.
Verify get_profile_metrics() returns ProfileMetrics type.
  </verify>
  <done>
Public API exposed: get_profile_metrics(), reset_profile_metrics().
All INST requirements satisfied.
  </done>
</task>

</tasks>

<verification>
- [ ] ProfileMetrics has cache_hits, cache_misses, atlas_*, peak_atlas_bytes fields
- [ ] cache_hit_rate() and atlas_utilization() derived functions work
- [ ] print_summary() outputs human-readable metrics
- [ ] get_or_load_glyph tracks hits/misses
- [ ] insert_bitmap tracks inserts/resets
- [ ] grow() tracks grows and memory bytes
- [ ] get_profile_metrics() aggregates all metrics
- [ ] reset_profile_metrics() clears counters
- [ ] Release build has zero profiling code (conditional compilation verified)
</verification>

<success_criteria>
- INST-01: Zero release overhead (conditional compilation)
- INST-02: Frame time breakdown (layout/rasterize/upload/draw)
- INST-03: Cache hit/miss rates tracked (glyph cache)
- INST-04: Memory tracking (peak_atlas_bytes, current_atlas_bytes)
- INST-05: Atlas utilization (used_pixels/total_pixels)

All requirements satisfied. Phase 8 complete.
</success_criteria>

<output>
After completion, create `.planning/phases/08-instrumentation/08-02-SUMMARY.md`
</output>
