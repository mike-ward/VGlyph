---
phase: 33-overlay-api-wiring
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - examples/editor_demo.v
  - ime_overlay_darwin.m
autonomous: false

must_haves:
  truths:
    - "editor_demo creates overlay via ime_overlay_create_auto and receives IME events through per-overlay callbacks"
    - "Running with --global-ime flag skips overlay discovery and uses global callbacks identical to v1.7"
    - "Status bar shows 'IME: overlay' or 'IME: global' based on active path"
    - "Two independent text fields exist with separate overlays and separate IME state"
    - "On overlay destroy, active IME composition is force-cancelled (not routed to global)"
    - "Global callback API still works identically to v1.7 when --global-ime is used"
  artifacts:
    - path: "examples/editor_demo.v"
      provides: "Per-overlay IME integration with two fields"
      contains: "ime_overlay_create_auto"
    - path: "ime_overlay_darwin.m"
      provides: "Force-cancel on overlay destroy"
      contains: "vglyph_overlay_free"
  key_links:
    - from: "examples/editor_demo.v"
      to: "c_bindings.v"
      via: "vglyph.ime_overlay_create_auto()"
      pattern: "ime_overlay_create_auto"
    - from: "examples/editor_demo.v"
      to: "c_bindings.v"
      via: "vglyph.ime_overlay_register_callbacks()"
      pattern: "ime_overlay_register_callbacks"
---

<objective>
Switch editor_demo from global IME callbacks to per-overlay API with
two independent text fields, --global-ime fallback flag, and status
indicator.

Purpose: Proves overlay API works end-to-end. Satisfies IME-02, IME-03,
IME-04. Two fields prove multi-field support per CONTEXT.md decision.

Output: editor_demo uses overlay path by default, global path via flag,
status text shows active path.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-overlay-api-wiring/33-CONTEXT.md
@.planning/phases/33-overlay-api-wiring/33-RESEARCH.md
@.planning/phases/33-overlay-api-wiring/33-01-SUMMARY.md
@examples/editor_demo.v
@c_bindings.v
@ime_overlay_darwin.m
@ime_overlay_darwin.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire editor_demo to per-overlay API with two fields</name>
  <files>
    examples/editor_demo.v
    ime_overlay_darwin.m
  </files>
  <action>
**ime_overlay_darwin.m** — Update `vglyph_overlay_free` to force-cancel
active IME composition before removing overlay (per CONTEXT.md: don't
route to global — state mismatch risk):

In `vglyph_overlay_free`, before `[overlay removeFromSuperview]`, add:
```objc
// Force-cancel any active IME composition (CONTEXT.md: no cross-handler routing)
if ([overlay hasMarkedText]) {
    // Discard composition without routing to global callbacks
    [overlay unmarkText];
}
// Resign first responder if this overlay had it
if ([[overlay window] firstResponder] == overlay) {
    [[overlay window] makeFirstResponder:overlay.mtkView];
}
```

**examples/editor_demo.v** — Major changes to init and frame functions:

1. **Add import** `import os` at top (for os.args).

2. **Add second text field state** to EditorState struct. Add fields:
   ```v
   // Second text field (multi-field demo)
   text2       string
   cfg2        vglyph.TextConfig
   layout2     vglyph.Layout
   cursor_idx2 int
   ime_overlay2 voidptr = unsafe { nil }
   active_field int = 1  // 1 or 2 — which field has focus

   // IME path tracking
   use_global_ime bool  // --global-ime flag
   ```

3. **Update init function** — Replace the current global callback
   registration (lines 124-137) with:

   ```v
   // Check for --global-ime flag (regression testing)
   state.use_global_ime = os.args.contains('--global-ime')

   if state.use_global_ime {
       // Global callback path (v1.7 compatible)
       vglyph.ime_register_callbacks(ime_marked_text, ime_insert_text,
           ime_unmark_text, ime_bounds, state_ptr)
   } else {
       // Per-overlay path: auto-discover MTKView from NSWindow
       $if darwin {
           ns_window := C.sapp_macos_get_window()
           state.ime_overlay = vglyph.ime_overlay_create_auto(ns_window)
           if state.ime_overlay == unsafe { nil } {
               eprintln('Warning: overlay creation failed, falling back to global')
               state.use_global_ime = true
               vglyph.ime_register_callbacks(ime_marked_text, ime_insert_text,
                   ime_unmark_text, ime_bounds, state_ptr)
           } else {
               // Register per-overlay callbacks for field 1
               vglyph.ime_overlay_register_callbacks(state.ime_overlay,
                   ime_on_marked_text, ime_on_insert_text, ime_on_unmark_text,
                   ime_on_get_bounds, ime_on_clause, ime_on_clauses_begin,
                   ime_on_clauses_end, state_ptr)
               // Focus field 1
               vglyph.ime_overlay_set_focused_field(state.ime_overlay, 'field1')

               // Create second overlay for field 2
               state.ime_overlay2 = vglyph.ime_overlay_create_auto(ns_window)
               if state.ime_overlay2 != unsafe { nil } {
                   vglyph.ime_overlay_register_callbacks(state.ime_overlay2,
                       ime_on_marked_text2, ime_on_insert_text2,
                       ime_on_unmark_text2, ime_on_get_bounds2,
                       ime_on_clause2, ime_on_clauses_begin2,
                       ime_on_clauses_end2, state_ptr)
               }
           }
       } $else {
           // Non-macOS: use global callbacks
           state.use_global_ime = true
           vglyph.ime_register_callbacks(ime_marked_text, ime_insert_text,
               ime_unmark_text, ime_bounds, state_ptr)
       }
   }
   ```

   Also declare the C function: `fn C.sapp_macos_get_window() voidptr`
   at the top of the file (before main fn) — this is already available
   via sokol, just needs declaration in the demo.

   Initialize second field text and config:
   ```v
   state.text2 = 'Second field — type here too'
   state.cfg2 = vglyph.TextConfig{
       style: vglyph.TextStyle{
           font_name: 'Sans 14'
           color: gg.Color{60, 60, 60, 255}
       }
       block: vglyph.BlockStyle{
           width: 300
           wrap: .word
       }
   }
   state.layout2 = state.ts.layout_text(state.text2, state.cfg2) or {
       panic(err)
   }
   ```

4. **Update frame function** — Add after existing text rendering,
   before status bar:

   - Draw a separator line at x=420
   - Draw field 2 at offset (430, 50) using state.text2/cfg2/layout2
   - Draw cursor for field 2 when active_field == 2
   - Highlight active field border (subtle rectangle outline)

   **Status bar** — Add IME path indicator after undo depth text:
   ```v
   // IME path indicator
   ime_path := if !state.use_global_ime && state.ime_overlay != unsafe { nil } {
       'IME: overlay'
   } else {
       'IME: global'
   }
   state.gg_ctx.draw_text(window_width - 200, int(status_y), ime_path,
       color: gg.gray)
   ```

5. **Update event handling** — Add field switching via mouse click:
   - If click x < 410: set active_field = 1, focus overlay 1, blur
     overlay 2
   - If click x >= 430: set active_field = 2, focus overlay 2, blur
     overlay 1
   - Route char/key events to active field's state
   - For field 2, use text2/cursor_idx2/layout2 in mutations

   Note: Full field-2 editing logic can be minimal (basic typing +
   cursor). The goal is proving two overlays work independently, not
   a full second editor. Handle insert and backspace for field 2;
   other editing features can be field-1 only.

6. **Add field 2 IME callbacks** — Create parallel callback functions
   for field 2 (ime_on_marked_text2, ime_on_insert_text2, etc.) that
   operate on state.text2/cursor_idx2/layout2. These follow the exact
   same pattern as the field 1 callbacks but target field 2 state.

7. **Cleanup on exit** — editor_demo doesn't have explicit cleanup,
   but if there's a cleanup/free path, call
   `vglyph.ime_overlay_free(state.ime_overlay)` and
   `vglyph.ime_overlay_free(state.ime_overlay2)`.

Run `v fmt -w examples/editor_demo.v` after all changes.
  </action>
  <verify>
1. `v -check-syntax examples/editor_demo.v` passes
2. `v fmt -w examples/editor_demo.v` produces no changes
3. `v build examples/editor_demo.v` succeeds on macOS
  </verify>
  <done>
editor_demo uses per-overlay API by default. Two text fields with
separate overlays. --global-ime flag forces global callbacks.
Status bar shows active IME path. Force-cancel on overlay destroy.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Per-overlay IME integration in editor_demo with two fields, MTKView
auto-discovery, --global-ime fallback, and status indicator.
  </what-built>
  <how-to-verify>
1. Run `v run examples/editor_demo.v` — verify status bar shows
   "IME: overlay"
2. Click in field 1, switch to Japanese IME, type "nihon" and
   confirm kanji conversion works
3. Click in field 2, type some text — verify it goes to field 2
   (not field 1)
4. Switch to Chinese IME in field 2, type "zhongguo" — verify
   pinyin composition works independently from field 1
5. Run `v run examples/editor_demo.v -- --global-ime` — verify
   status bar shows "IME: global" and Japanese/Chinese IME still
   works (v1.7 behavior)
6. Verify cross-platform: `v build examples/editor_demo.v` on
   Linux (if available) OR confirm `ime_overlay_stub.c` compiles
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `v build examples/editor_demo.v` succeeds
2. Demo shows "IME: overlay" in status bar by default
3. Demo shows "IME: global" with --global-ime flag
4. Japanese IME works through overlay path
5. Two fields accept input independently
6. Switching fields changes overlay focus
</verification>

<success_criteria>
editor_demo creates overlays via auto-discovery, receives IME events
through per-overlay callbacks, shows two independent text fields,
supports --global-ime fallback flag, displays active IME path in
status bar.
</success_criteria>

<output>
After completion, create `.planning/phases/33-overlay-api-wiring/33-02-SUMMARY.md`
</output>
