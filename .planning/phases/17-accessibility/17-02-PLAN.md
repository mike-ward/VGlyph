---
phase: 17-accessibility
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - accessibility/announcer.v
  - accessibility/emoji_names.v
  - examples/editor_demo.v
autonomous: false

must_haves:
  truths:
    - "VoiceOver announces cursor position changes"
    - "VoiceOver announces selection changes"
    - "Announcements follow verbosity decisions from CONTEXT.md"
    - "Word jump announces 'moved to: word'"
    - "Dead key announces accent then final result"
    - "Emoji announces short name when available"
  artifacts:
    - path: "accessibility/announcer.v"
      provides: "AccessibilityAnnouncer with announce_* methods"
      contains: "AccessibilityAnnouncer"
    - path: "accessibility/emoji_names.v"
      provides: "Common emoji short name lookup"
      contains: "get_emoji_name"
    - path: "examples/editor_demo.v"
      provides: "Accessibility integration in editor demo"
      contains: "a11y_announcer"
  key_links:
    - from: "examples/editor_demo.v"
      to: "accessibility/announcer.v"
      via: "announcer method calls on cursor/selection change"
      pattern: "a11y_announcer\\.announce"
    - from: "examples/editor_demo.v"
      to: "accessibility/manager.v"
      via: "notification posting on state change"
      pattern: "manager\\.post_notification"
---

<objective>
Create AccessibilityAnnouncer for explicit VoiceOver feedback and integrate accessibility into
editor_demo.v.

Purpose: Enable VoiceOver users to navigate and edit text with auditory feedback per CONTEXT.md
verbosity decisions.
Output: Working editor demo with VoiceOver support.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-accessibility/17-CONTEXT.md
@.planning/phases/17-accessibility/17-RESEARCH.md
@.planning/phases/17-accessibility/17-01-SUMMARY.md
@accessibility/accessibility_types.v
@accessibility/manager.v
@examples/editor_demo.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AccessibilityAnnouncer with verbosity-aware announcements</name>
  <files>accessibility/announcer.v, accessibility/emoji_names.v</files>
  <action>
Create new file accessibility/announcer.v implementing announcement helpers per CONTEXT.md decisions:

```v
module accessibility

import time

// LineBoundary indicates cursor at line start/end
pub enum LineBoundary {
    beginning
    end
}

// DocBoundary indicates cursor at document start/end
pub enum DocBoundary {
    beginning
    end
}

// AccessibilityAnnouncer provides explicit VoiceOver announcements.
// Follows verbosity decisions from Phase 17 CONTEXT.md.
pub struct AccessibilityAnnouncer {
mut:
    last_announcement_time i64
    debounce_ms            i64 = 150  // Per screen reader research (150-200ms)
    last_line              int = -1   // Track line changes
}

pub fn new_accessibility_announcer() AccessibilityAnnouncer {
    return AccessibilityAnnouncer{}
}

// announce_character - character only, no phonetic spelling (per CONTEXT.md)
// Punctuation/whitespace: symbolic names
// Emoji: short name if available (per CONTEXT.md)
pub fn (mut ann AccessibilityAnnouncer) announce_character(ch rune) string {
    if !ann.should_announce() {
        return ''
    }
    message := match ch {
        ` ` { 'space' }
        `\t` { 'tab' }
        `\n` { 'newline' }
        `.` { 'period' }
        `,` { 'comma' }
        `;` { 'semicolon' }
        `:` { 'colon' }
        `!` { 'exclamation' }
        `?` { 'question' }
        `'` { 'apostrophe' }
        `"` { 'quote' }
        `(` { 'open paren' }
        `)` { 'close paren' }
        `[` { 'open bracket' }
        `]` { 'close bracket' }
        `{` { 'open brace' }
        `}` { 'close brace' }
        else {
            // Check for emoji short name (per CONTEXT.md: short name if available)
            emoji_name := get_emoji_name(ch)
            if emoji_name.len > 0 {
                emoji_name
            } else {
                ch.str()  // Plain character
            }
        }
    }
    ann.log_announcement(message)
    return message
}

// announce_word_jump - brief context preview: 'moved to: word' (per CONTEXT.md)
// CONTEXT.md specifies: "Word jump / Home/End: brief context preview ('moved to: hello world')"
pub fn (mut ann AccessibilityAnnouncer) announce_word_jump(word string) string {
    if !ann.should_announce() {
        return ''
    }
    message := 'moved to: ${word}'
    ann.log_announcement(message)
    return message
}

// announce_line_boundary - 'beginning of line' / 'end of line' (per CONTEXT.md)
pub fn (mut ann AccessibilityAnnouncer) announce_line_boundary(boundary LineBoundary) string {
    if !ann.should_announce() {
        return ''
    }
    message := match boundary {
        .beginning { 'beginning of line' }
        .end { 'end of line' }
    }
    ann.log_announcement(message)
    return message
}

// announce_line_number - always announce on line change (per CONTEXT.md)
pub fn (mut ann AccessibilityAnnouncer) announce_line_number(line int) string {
    if line == ann.last_line {
        return ''  // Same line, don't announce
    }
    ann.last_line = line
    if !ann.should_announce() {
        return ''
    }
    message := 'line ${line}'
    ann.log_announcement(message)
    return message
}

// announce_document_boundary - 'beginning of document' / 'end of document' (per CONTEXT.md)
pub fn (mut ann AccessibilityAnnouncer) announce_document_boundary(boundary DocBoundary) string {
    if !ann.should_announce() {
        return ''
    }
    message := match boundary {
        .beginning { 'beginning of document' }
        .end { 'end of document' }
    }
    ann.log_announcement(message)
    return message
}

// announce_selection - read short (<= 20 chars), count long (per CONTEXT.md)
pub fn (mut ann AccessibilityAnnouncer) announce_selection(selected_text string) string {
    if !ann.should_announce() {
        return ''
    }
    message := if selected_text.len <= 20 {
        selected_text  // Read the actual text
    } else {
        char_count := selected_text.runes().len
        '${char_count} characters selected'
    }
    ann.log_announcement(message)
    return message
}

// announce_selection_extended - 'added: X' (per CONTEXT.md)
pub fn (mut ann AccessibilityAnnouncer) announce_selection_extended(added_text string) string {
    if !ann.should_announce() {
        return ''
    }
    message := 'added: ${added_text}'
    ann.log_announcement(message)
    return message
}

// announce_selection_cleared - 'deselected' (per CONTEXT.md)
pub fn (mut ann AccessibilityAnnouncer) announce_selection_cleared() string {
    if !ann.should_announce() {
        return ''
    }
    message := 'deselected'
    ann.log_announcement(message)
    return message
}

// announce_dead_key - announce dead key character (per CONTEXT.md)
// CONTEXT.md: "Dead key sequences: announce dead key ('grave accent'), then final result"
pub fn (mut ann AccessibilityAnnouncer) announce_dead_key(dead_key rune) string {
    if !ann.should_announce() {
        return ''
    }
    message := match dead_key {
        `\`` { 'grave accent' }
        `´` { 'acute accent' }
        `^` { 'circumflex' }
        `~` { 'tilde' }
        `¨` { 'umlaut' }
        `¸` { 'cedilla' }
        else { 'dead key' }
    }
    ann.log_announcement(message)
    return message
}

// announce_dead_key_result - announce the final composed character (per CONTEXT.md)
// CONTEXT.md: "Dead key sequences: announce dead key ('grave accent'), then final result"
// Called after composition commits to announce what was actually inserted
pub fn (mut ann AccessibilityAnnouncer) announce_dead_key_result(ch rune) string {
    // Don't debounce result - always announce after dead key
    message := ch.str()
    ann.log_announcement(message)
    return message
}

// announce_composition_cancelled - 'composition cancelled' (per CONTEXT.md)
pub fn (mut ann AccessibilityAnnouncer) announce_composition_cancelled() string {
    if !ann.should_announce() {
        return ''
    }
    message := 'composition cancelled'
    ann.log_announcement(message)
    return message
}

// should_announce checks debounce timing
fn (mut ann AccessibilityAnnouncer) should_announce() bool {
    now := time.now().unix_milli()
    if now - ann.last_announcement_time < ann.debounce_ms {
        return false  // Too soon
    }
    ann.last_announcement_time = now
    return true
}

// log_announcement outputs to stderr for debugging
// In production, this would post to VoiceOver via NSAccessibility
fn (ann AccessibilityAnnouncer) log_announcement(message string) {
    eprintln('[VoiceOver] ${message}')
}
```

Create new file accessibility/emoji_names.v with common emoji short names (per CONTEXT.md: "short
name if available"):

```v
module accessibility

// get_emoji_name returns short name for common emoji (per CONTEXT.md)
// Returns empty string if not an emoji or name unknown
pub fn get_emoji_name(ch rune) string {
    // Common emoji with short names (subset - expandable)
    // Unicode codepoint -> friendly name
    return match ch {
        // Smileys
        0x1F600 { 'grinning face' }
        0x1F601 { 'beaming face' }
        0x1F602 { 'tears of joy' }
        0x1F603 { 'smiling face' }
        0x1F604 { 'grinning squinting face' }
        0x1F605 { 'grinning face with sweat' }
        0x1F606 { 'squinting face' }
        0x1F607 { 'smiling face with halo' }
        0x1F609 { 'winking face' }
        0x1F60A { 'smiling face with smiling eyes' }
        0x1F60B { 'face savoring food' }
        0x1F60C { 'relieved face' }
        0x1F60D { 'heart eyes' }
        0x1F60E { 'sunglasses face' }
        0x1F60F { 'smirking face' }
        0x1F610 { 'neutral face' }
        0x1F611 { 'expressionless face' }
        0x1F612 { 'unamused face' }
        0x1F613 { 'downcast face with sweat' }
        0x1F614 { 'pensive face' }
        0x1F615 { 'confused face' }
        0x1F616 { 'confounded face' }
        0x1F617 { 'kissing face' }
        0x1F618 { 'face blowing kiss' }
        0x1F619 { 'kissing face with smiling eyes' }
        0x1F61A { 'kissing face with closed eyes' }
        0x1F61B { 'face with tongue' }
        0x1F61C { 'winking face with tongue' }
        0x1F61D { 'squinting face with tongue' }
        0x1F61E { 'disappointed face' }
        0x1F61F { 'worried face' }
        0x1F620 { 'angry face' }
        0x1F621 { 'pouting face' }
        0x1F622 { 'crying face' }
        0x1F623 { 'persevering face' }
        0x1F624 { 'face with steam' }
        0x1F625 { 'sad but relieved face' }
        0x1F626 { 'frowning face with open mouth' }
        0x1F627 { 'anguished face' }
        0x1F628 { 'fearful face' }
        0x1F629 { 'weary face' }
        0x1F62A { 'sleepy face' }
        0x1F62B { 'tired face' }
        0x1F62C { 'grimacing face' }
        0x1F62D { 'loudly crying face' }
        0x1F62E { 'face with open mouth' }
        0x1F62F { 'hushed face' }
        0x1F630 { 'anxious face with sweat' }
        0x1F631 { 'face screaming' }
        0x1F632 { 'astonished face' }
        0x1F633 { 'flushed face' }
        0x1F634 { 'sleeping face' }
        0x1F635 { 'dizzy face' }
        0x1F636 { 'face without mouth' }
        0x1F637 { 'face with medical mask' }
        // Gestures
        0x1F44D { 'thumbs up' }
        0x1F44E { 'thumbs down' }
        0x1F44F { 'clapping hands' }
        0x1F64C { 'raising hands' }
        0x1F64F { 'folded hands' }
        0x270B { 'raised hand' }
        0x270C { 'victory hand' }
        0x1F44B { 'waving hand' }
        0x1F44A { 'fist' }
        0x1F91D { 'handshake' }
        // Hearts
        0x2764 { 'red heart' }
        0x1F494 { 'broken heart' }
        0x1F495 { 'two hearts' }
        0x1F496 { 'sparkling heart' }
        0x1F497 { 'growing heart' }
        0x1F498 { 'heart with arrow' }
        0x1F499 { 'blue heart' }
        0x1F49A { 'green heart' }
        0x1F49B { 'yellow heart' }
        0x1F49C { 'purple heart' }
        0x1F5A4 { 'black heart' }
        // Common symbols
        0x2705 { 'check mark' }
        0x274C { 'cross mark' }
        0x2B50 { 'star' }
        0x1F525 { 'fire' }
        0x1F4A1 { 'light bulb' }
        0x1F389 { 'party popper' }
        0x1F680 { 'rocket' }
        0x1F4AF { 'hundred points' }
        0x1F914 { 'thinking face' }
        0x1F923 { 'rolling on floor laughing' }
        else { '' }  // Not a known emoji
    }
}
```
  </action>
  <verify>v -check-syntax accessibility/announcer.v && v -check-syntax accessibility/emoji_names.v && v fmt -verify accessibility/announcer.v && v fmt -verify accessibility/emoji_names.v</verify>
  <done>AccessibilityAnnouncer with all announcement methods per CONTEXT.md verbosity decisions including: word jump returns 'moved to: word', dead key result announcement, emoji short names.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate accessibility into editor_demo.v</name>
  <files>examples/editor_demo.v</files>
  <action>
Modify editor_demo.v to add accessibility support:

1. Add imports:
   - `import accessibility`

2. Add to EditorState struct:
   ```v
   // Accessibility support
   a11y_announcer accessibility.AccessibilityAnnouncer
   a11y_manager   &accessibility.AccessibilityManager = unsafe { nil }
   a11y_node_id   int = -1  // Text field node ID
   a11y_enabled   bool
   prev_line      int = -1  // Track line changes for announcements
   in_dead_key    bool      // Track dead key composition state
   ```

3. In init():
   - Initialize announcer: `state.a11y_announcer = accessibility.new_accessibility_announcer()`
   - Initialize manager: `state.a11y_manager = accessibility.new_accessibility_manager()`
   - Create text field node: `state.a11y_node_id = state.a11y_manager.create_text_field_node(...)`
   - Set a11y_enabled = true

4. In event() key_down handler, after cursor movement:
   - After .left/.right char movement:
     ```v
     // Announce character at new cursor position
     if state.a11y_enabled && state.cursor_idx < state.text.len {
         ch := rune(state.text[state.cursor_idx])
         state.a11y_announcer.announce_character(ch)
     }
     // Post notification to VoiceOver via manager
     if state.a11y_enabled && state.a11y_node_id >= 0 {
         state.a11y_manager.post_notification(state.a11y_node_id, .value_changed)
     }
     ```
   - After Cmd+left/right word movement (also applies to Home/End per CONTEXT.md):
     ```v
     // Announce with context preview: 'moved to: word' (per CONTEXT.md)
     if state.a11y_enabled {
         start, end := state.layout.get_word_at_index(state.cursor_idx)
         if end > start {
             word := state.text[start..end]
             state.a11y_announcer.announce_word_jump(word)
         }
     }
     ```
   - After .home:
     ```v
     if state.a11y_enabled {
         state.a11y_announcer.announce_line_boundary(.beginning)
         // Also announce word context (per CONTEXT.md: Home/End gets context preview)
         start, end := state.layout.get_word_at_index(state.cursor_idx)
         if end > start {
             word := state.text[start..end]
             state.a11y_announcer.announce_word_jump(word)
         }
     }
     ```
   - After .end:
     ```v
     if state.a11y_enabled {
         state.a11y_announcer.announce_line_boundary(.end)
         // Also announce word context (per CONTEXT.md: Home/End gets context preview)
         start, end := state.layout.get_word_at_index(state.cursor_idx)
         if end > start {
             word := state.text[start..end]
             state.a11y_announcer.announce_word_jump(word)
         }
     }
     ```

5. After any cursor movement, check line change:
   ```v
   // Announce line number on line change
   if state.a11y_enabled {
       new_line, _ := calc_line_col(state.layout, state.cursor_idx)
       state.a11y_announcer.announce_line_number(new_line)
   }
   ```

6. After selection changes (in key_down shift+arrow handling):
   ```v
   if state.a11y_enabled && state.has_selection {
       sel_text := vglyph.get_selected_text(state.text, state.cursor_idx, state.anchor_idx)
       state.a11y_announcer.announce_selection(sel_text)
       // Post selection changed notification
       if state.a11y_node_id >= 0 {
           state.a11y_manager.post_notification(state.a11y_node_id, .selected_text_changed)
       }
   }
   ```

7. When selection is cleared:
   ```v
   if state.a11y_enabled && was_selected && !state.has_selection {
       state.a11y_announcer.announce_selection_cleared()
   }
   ```

8. In dead key handling (when dead key detected in IME callback):
   ```v
   if state.a11y_enabled {
       state.a11y_announcer.announce_dead_key(dead_key_rune)
       state.in_dead_key = true
   }
   ```

9. When dead key composition commits (character inserted after dead key):
   ```v
   // Per CONTEXT.md: announce dead key THEN final result
   if state.a11y_enabled && state.in_dead_key {
       state.a11y_announcer.announce_dead_key_result(committed_char)
       state.in_dead_key = false
   }
   ```

10. When composition cancelled (Escape):
   ```v
   if state.a11y_enabled {
       state.a11y_announcer.announce_composition_cancelled()
       state.in_dead_key = false
   }
   ```

11. After text changes, update accessibility manager:
    ```v
    // Update text field attributes and post notification
    if state.a11y_enabled && state.a11y_node_id >= 0 {
        line, _ := calc_line_col(state.layout, state.cursor_idx)
        state.a11y_manager.update_text_field(
            state.a11y_node_id,
            state.text,
            accessibility.Range{ location: state.cursor_idx, length: 0 },
            line
        )
        state.a11y_manager.post_notification(state.a11y_node_id, .value_changed)
    }
    ```
  </action>
  <verify>v -check-syntax examples/editor_demo.v && v fmt -w examples/editor_demo.v</verify>
  <done>Editor demo has accessibility announcer AND manager integration with VoiceOver feedback on navigation/editing. Manager.post_notification called on state changes.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
VoiceOver accessibility support for editor_demo:
- Cursor navigation announces character/word/line
- Word jump announces 'moved to: word' (per CONTEXT.md)
- Selection changes announced
- Line boundaries announced
- Dead key announces accent THEN final result (per CONTEXT.md)
- Emoji announces short name (per CONTEXT.md)
- Manager.post_notification called on state changes
  </what-built>
  <how-to-verify>
1. Build and run editor demo:
   ```
   v run examples/editor_demo.v
   ```

2. Watch stderr for [VoiceOver] messages (announcements logged there)

3. Test navigation announcements:
   - Arrow left/right: should see character announcements (with symbolic names for punctuation)
   - Cmd+Arrow: should see 'moved to: word' format
   - Home/End: should see 'beginning of line' / 'end of line' PLUS 'moved to: word'
   - Up/Down across lines: should see 'line N' announcements

4. Test selection announcements:
   - Shift+Arrow: should see selection text or count
   - Click elsewhere to deselect: should see 'deselected'

5. Test IME announcements:
   - Option+` (grave dead key): should see 'grave accent'
   - Type 'e' after dead key: should see 'grave accent' then 'e' (the result)
   - Escape during composition: should see 'composition cancelled'

6. Test emoji (if you can insert emoji):
   - Insert grinning face emoji: should see 'grinning face' not raw unicode

7. (Optional) Enable VoiceOver (Cmd+F5) and verify screen reader integration
  </how-to-verify>
  <resume-signal>Type "approved" if announcements work correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
- All V files compile: `v -check-syntax accessibility/ && v -check-syntax examples/editor_demo.v`
- Editor demo runs without errors
- VoiceOver announcements appear in stderr when navigating
- Announcement verbosity matches CONTEXT.md decisions:
  - Word jump: 'moved to: word' format
  - Dead key: accent name then final result
  - Emoji: short name if available
</verification>

<success_criteria>
- AccessibilityAnnouncer exists with all announcement methods per CONTEXT.md
- announce_word_jump returns 'moved to: ${word}' (per CONTEXT.md locked decision)
- announce_dead_key_result method exists for announcing composed character
- get_emoji_name function returns short names for common emoji
- Editor demo integrates announcer AND manager (post_notification calls)
- Character navigation: announces character (symbolic for punctuation/whitespace)
- Word navigation: announces 'moved to: word'
- Line boundaries: announces 'beginning/end of line' plus word context
- Line changes: announces 'line N'
- Selection: reads short text, counts long text
- Dead keys: announces accent name THEN final result
- Human verification confirms announcements work as expected
</success_criteria>

<output>
After completion, create `.planning/phases/17-accessibility/17-02-SUMMARY.md`
</output>
