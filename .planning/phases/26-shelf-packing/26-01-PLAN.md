---
phase: 26-shelf-packing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - glyph_atlas.v
autonomous: true

must_haves:
  truths:
    - "Glyphs allocate to best-fitting shelf (minimum vertical waste)"
    - "New shelves created only when waste > 50% of glyph height"
    - "Page-level LRU eviction unchanged (page.age updates as before)"
    - "Atlas utilization >= 75% on typical text"
  artifacts:
    - path: "glyph_atlas.v"
      provides: "Shelf struct, shelf-based AtlasPage, BHF insert"
      contains: "struct Shelf"
    - path: "glyph_atlas.v"
      provides: "Best-height-fit allocation"
      contains: "find_best_shelf"
  key_links:
    - from: "insert_bitmap"
      to: "Shelf"
      via: "find_best_shelf + shelf allocation"
      pattern: "find_best_shelf.*shelves"
    - from: "reset_page"
      to: "shelves"
      via: "clear shelf array"
      pattern: "shelves.clear\\(\\)|shelves = \\[\\]"
---

<objective>
Implement shelf-based atlas allocation with best-height-fit algorithm

Purpose: Replace simple row packing with shelf BHF to improve atlas utilization from ~70% to 75%+.
Current implementation advances cursor_y by tallest glyph in row, wasting vertical space for
shorter glyphs. Shelf BHF maintains multiple shelves, places each glyph on shelf minimizing
vertical waste.

Output: Modified glyph_atlas.v with Shelf struct, per-shelf tracking, and BHF allocation
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/26-shelf-packing/26-RESEARCH.md

# Source file to modify
@glyph_atlas.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Shelf struct and refactor AtlasPage</name>
  <files>glyph_atlas.v</files>
  <action>
1. Add Shelf struct after CachedGlyph definition:
```v
struct Shelf {
mut:
    y        int  // Vertical position of shelf top
    height   int  // Shelf height (fixed at creation)
    cursor_x int  // Next free x position
    width    int  // Shelf width (page width)
}
```

2. Modify AtlasPage struct:
   - Remove: cursor_x, cursor_y, row_height fields
   - Add: shelves []Shelf

3. Update new_atlas_page:
   - Initialize shelves as empty array: shelves: []Shelf{}
   - Remove cursor/row_height initialization

4. Update reset_page:
   - Clear shelves: page.shelves.clear() or page.shelves = []Shelf{}
   - Keep page.age = atlas.frame_counter (LRU preservation)
   - Keep page.used_pixels = 0
   - Keep memory zeroing (vmemset)

5. Update grow_page:
   - No changes to shelf array (heights unchanged, just page grew)
   - Keep dirty flag, memory tracking

Do NOT modify insert_bitmap yet - that's next task.
  </action>
  <verify>
`v -check-syntax glyph_atlas.v` succeeds (no syntax errors)
Note: Compilation will fail until Task 2 updates insert_bitmap
  </verify>
  <done>
Shelf struct exists. AtlasPage uses shelves[] instead of cursor_x/cursor_y/row_height.
reset_page clears shelves. Page-level LRU tracking (page.age) unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement shelf BHF allocation in insert_bitmap</name>
  <files>glyph_atlas.v</files>
  <action>
1. Add helper function find_best_shelf after insert_bitmap:
```v
// find_best_shelf returns index of shelf with minimum vertical waste for glyph_h.
// Returns -1 if no suitable shelf found (none fit or all would waste > threshold).
fn (page &AtlasPage) find_best_shelf(glyph_w int, glyph_h int) int {
    mut best_idx := -1
    mut best_waste := max_i32

    for i, shelf in page.shelves {
        // Glyph must fit vertically
        if glyph_h > shelf.height {
            continue
        }
        // Glyph must fit horizontally
        if shelf.cursor_x + glyph_w > shelf.width {
            continue
        }

        waste := shelf.height - glyph_h
        if waste < best_waste {
            best_waste = waste
            best_idx = i
        }
    }

    // Create new shelf if wasting > 50% of glyph height
    if best_idx >= 0 && best_waste > glyph_h / 2 {
        return -1  // Signal to create new shelf
    }

    return best_idx
}

// get_next_shelf_y returns Y position for next shelf (bottom of last shelf).
fn (page &AtlasPage) get_next_shelf_y() int {
    if page.shelves.len == 0 {
        return 0
    }
    last := page.shelves[page.shelves.len - 1]
    return last.y + last.height
}
```

2. Rewrite insert_bitmap allocation logic (replace cursor_x/cursor_y code):
```v
// After dimension validation, empty glyph check...

mut page := &atlas.pages[atlas.current_page]
// ... keep reset_occurred, reset_page_idx...

// Find best existing shelf or create new
mut shelf_idx := page.find_best_shelf(glyph_w, glyph_h)

if shelf_idx < 0 {
    // Need new shelf - check if it fits
    new_y := page.get_next_shelf_y()
    if new_y + glyph_h > page.height {
        // Page full - try grow/add/reset (existing logic)
        // ... existing grow_page / add new page / reset oldest logic ...
        // After getting new/reset page, refresh and retry
        page = &atlas.pages[atlas.current_page]
        shelf_idx = page.find_best_shelf(glyph_w, glyph_h)
    }

    // Create new shelf if still needed
    if shelf_idx < 0 {
        new_y := page.get_next_shelf_y()
        if new_y + glyph_h > page.height {
            return error('glyph too large for atlas page')
        }
        page.shelves << Shelf{
            y:        new_y
            height:   glyph_h
            cursor_x: 0
            width:    page.width
        }
        shelf_idx = page.shelves.len - 1
    }
}

// Allocate from chosen shelf
mut shelf := &page.shelves[shelf_idx]
x := shelf.cursor_x
y := shelf.y
shelf.cursor_x += glyph_w

// Copy bitmap
copy_bitmap_to_page(mut page, bmp, x, y)!
page.dirty = true

// Build CachedGlyph
cached := CachedGlyph{
    x:      x
    y:      y
    width:  glyph_w
    height: glyph_h
    left:   left
    top:    top
    page:   atlas.current_page
}

// Update used_pixels: sum of (cursor_x * height) for all shelves
page.used_pixels = page.calculate_shelf_used_pixels()

return cached, reset_occurred, reset_page_idx
```

3. Add used_pixels calculation helper:
```v
fn (page &AtlasPage) calculate_shelf_used_pixels() i64 {
    mut used := i64(0)
    for shelf in page.shelves {
        used += i64(shelf.cursor_x) * i64(shelf.height)
    }
    return used
}
```

4. Preserve existing page management logic:
   - Keep grow_page call when page.height < atlas.max_height
   - Keep new page creation when atlas.pages.len < atlas.max_pages
   - Keep reset_page for oldest when all pages full
   - Keep all profile instrumentation ($if profile)
  </action>
  <verify>
```bash
v fmt -w glyph_atlas.v && v -check-syntax glyph_atlas.v
v run examples/atlas_debug.v  # Visual check: glyphs render correctly
```
  </verify>
  <done>
insert_bitmap uses shelf BHF: finds best shelf, creates new only when needed,
allocates horizontally within shelf. Page grow/add/reset logic preserved.
used_pixels calculated from actual shelf usage.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify utilization with profile flag</name>
  <files>glyph_atlas.v</files>
  <action>
1. Run atlas_debug with profile flag to measure utilization:
```bash
v -d profile run examples/atlas_debug.v
```

2. Check profile output for utilization metrics. Expected:
   - atlas_inserts: reflects glyph count
   - used_pixels / (page.width * page.height): should be >= 0.75 for typical text

3. If utilization < 75%, check:
   - Shelf count (too many small shelves = fragmentation)
   - Waste threshold (50% may need tuning)
   - Capture current utilization for SUMMARY

4. Run existing tests to verify no regressions:
```bash
v test .
```

5. Format and final check:
```bash
v fmt -w glyph_atlas.v
v -check-syntax glyph_atlas.v
```
  </action>
  <verify>
```bash
v test .  # All tests pass
v -d profile run examples/atlas_debug.v 2>&1 | grep -i atlas  # Profile output shows metrics
```
  </verify>
  <done>
Shelf BHF algorithm complete. Tests pass. Profile metrics show utilization.
Ready for debug visualization in Plan 02.
  </done>
</task>

</tasks>

<verification>
1. `v fmt -w glyph_atlas.v` succeeds
2. `v test .` passes all existing tests
3. `v run examples/atlas_debug.v` displays glyphs correctly
4. `v -d profile run examples/atlas_debug.v` shows atlas metrics
5. Shelf struct exists with y, height, cursor_x, width fields
6. AtlasPage.shelves array replaces cursor_x/cursor_y/row_height
7. Page-level LRU (page.age) unchanged in reset_page
</verification>

<success_criteria>
- Glyphs render correctly in atlas_debug example
- Tests pass (no regressions)
- Shelf BHF allocation: best-fit search, new shelf creation with waste threshold
- Page management (grow/add/reset) unchanged
- used_pixels reflects actual shelf usage
</success_criteria>

<output>
After completion, create `.planning/phases/26-shelf-packing/26-01-SUMMARY.md`
</output>
