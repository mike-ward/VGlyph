---
phase: 13-text-mutation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/layout_mutation.v
autonomous: true

must_haves:
  truths:
    - "Backspace at cursor deletes one grapheme cluster"
    - "Delete key removes character after cursor"
    - "Option+Backspace deletes to word boundary"
    - "Cmd+Backspace deletes to line start"
    - "Insert text at cursor position works"
  artifacts:
    - path: "layout_mutation.v"
      provides: "Text mutation primitives"
      exports: ["MutationResult", "delete_backward", "delete_forward", "insert_text"]
      contains: "pub struct MutationResult"
  key_links:
    - from: "layout_mutation.v"
      to: "layout_query.v"
      via: "move_cursor_left/right for grapheme boundaries"
      pattern: "layout\\.move_cursor"
---

<objective>
Core text mutation primitives for insertion and deletion operations.

Purpose: Enable text editing by providing grapheme-aware delete/insert functions that return
mutation results with new text, cursor position, and deleted text (for undo support).

Output: New layout_mutation.v file with MutationResult struct and core mutation functions.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-text-mutation/13-CONTEXT.md
@.planning/phases/13-text-mutation/13-RESEARCH.md
@layout_query.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MutationResult struct and backward deletion</name>
  <files>layout_mutation.v</files>
  <action>
Create new file layout_mutation.v in module vglyph with:

1. MutationResult struct:
```v
pub struct MutationResult {
pub:
    new_text     string  // Result of applying mutation
    cursor_pos   int     // New cursor position after mutation
    deleted_text string  // Text removed (empty for insert)
    range_start  int     // Start of affected range (for change event)
    range_end    int     // End of affected range (for change event)
}
```

2. delete_backward function:
- Takes: text string, layout Layout, cursor int
- Returns: MutationResult
- At cursor 0: return unchanged (new_text: text, cursor_pos: 0)
- Find previous valid position via layout.move_cursor_left(cursor)
- Use strings.Builder to construct new_text: text[..prev_pos] + text[cursor..]
- Return result with deleted_text: text[prev_pos..cursor]

3. delete_forward function:
- Takes: text string, layout Layout, cursor int
- Returns: MutationResult
- At text end: return unchanged
- Find next valid position via layout.move_cursor_right(cursor)
- Build new_text: text[..cursor] + text[next_pos..]
- Cursor stays at same position
- Return result with deleted_text: text[cursor..next_pos]

Use strings.Builder for efficient string building (not + concatenation).
Import strings module.
  </action>
  <verify>v fmt -w layout_mutation.v && v -check-syntax layout_mutation.v</verify>
  <done>MutationResult struct exists, delete_backward/forward handle grapheme clusters</done>
</task>

<task type="auto">
  <name>Task 2: Add insert_text and word/line deletion</name>
  <files>layout_mutation.v</files>
  <action>
Add to layout_mutation.v:

1. insert_text function:
- Takes: text string, cursor int, insert string
- Returns: MutationResult
- Build: text[..cursor] + insert + text[cursor..]
- New cursor: cursor + insert.len
- deleted_text: empty string
- range_start: cursor, range_end: cursor + insert.len

2. delete_to_word_boundary function (Option+Backspace):
- Takes: text string, layout Layout, cursor int
- Returns: MutationResult
- At cursor 0: return unchanged
- Find word start via layout.move_cursor_word_left(cursor)
- Build: text[..word_start] + text[cursor..]
- Return with deleted_text: text[word_start..cursor]
- Per user decision: "to boundary, not whole word"

3. delete_to_line_start function (Cmd+Backspace):
- Takes: text string, layout Layout, cursor int
- Returns: MutationResult
- Find line start via layout.move_cursor_line_start(cursor)
- Build: text[..line_start] + text[cursor..]
- Return with deleted_text: text[line_start..cursor]

4. delete_to_line_end function (Cmd+Delete):
- Takes: text string, layout Layout, cursor int
- Returns: MutationResult
- Find line end via layout.move_cursor_line_end(cursor)
- Build: text[..cursor] + text[line_end..]
- Cursor stays at cursor position
- Return with deleted_text: text[cursor..line_end]

5. delete_to_word_end function (Option+Delete):
- Takes: text string, layout Layout, cursor int
- Returns: MutationResult
- Find word end via layout.move_cursor_word_right(cursor)
- Build: text[..cursor] + text[word_end..]
- Cursor stays at cursor
- Return with deleted_text: text[cursor..word_end]
  </action>
  <verify>v fmt -w layout_mutation.v && v -check-syntax layout_mutation.v</verify>
  <done>insert_text, word deletion, line deletion all work correctly</done>
</task>

<task type="auto">
  <name>Task 3: Add selection-aware delete function</name>
  <files>layout_mutation.v</files>
  <action>
Add to layout_mutation.v:

1. delete_selection function:
- Takes: text string, cursor int, anchor int
- Returns: MutationResult
- If cursor == anchor: return unchanged (no selection)
- Calculate sel_start = min(cursor, anchor), sel_end = max(cursor, anchor)
- Build: text[..sel_start] + text[sel_end..]
- New cursor: sel_start
- deleted_text: text[sel_start..sel_end]
- range_start: sel_start, range_end: sel_start (selection collapsed)

2. insert_replacing_selection function:
- Takes: text string, cursor int, anchor int, insert string
- Returns: MutationResult
- If cursor == anchor: delegate to insert_text(text, cursor, insert)
- Calculate sel_start = min(cursor, anchor), sel_end = max(cursor, anchor)
- Build: text[..sel_start] + insert + text[sel_end..]
- New cursor: sel_start + insert.len
- deleted_text: text[sel_start..sel_end]
- range_start: sel_start, range_end: sel_start + insert.len

Per user decision: "Typing with selection active replaces selection (standard behavior)"
  </action>
  <verify>v fmt -w layout_mutation.v && v -check-syntax layout_mutation.v</verify>
  <done>Selection-based deletion and replacement work correctly</done>
</task>

</tasks>

<verification>
1. v fmt -w layout_mutation.v - File formatted correctly
2. v -check-syntax layout_mutation.v - No syntax errors
3. All public functions have correct signatures matching RESEARCH.md patterns
4. strings.Builder used for string concatenation (not + operator)
5. MutationResult includes all fields needed for undo (deleted_text, range_start, range_end)
</verification>

<success_criteria>
- [ ] layout_mutation.v exists with MutationResult struct
- [ ] delete_backward uses move_cursor_left for grapheme boundaries
- [ ] delete_forward uses move_cursor_right for grapheme boundaries
- [ ] insert_text places text at cursor and advances cursor
- [ ] delete_to_word_boundary uses move_cursor_word_left
- [ ] delete_to_line_start uses move_cursor_line_start
- [ ] delete_selection handles cursor > anchor and cursor < anchor
- [ ] insert_replacing_selection combines delete + insert
- [ ] All functions use strings.Builder
</success_criteria>

<output>
After completion, create `.planning/phases/13-text-mutation/13-01-SUMMARY.md`
</output>
