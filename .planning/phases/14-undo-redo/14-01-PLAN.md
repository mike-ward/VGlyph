---
phase: 14-undo-redo
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [undo.v]
autonomous: true

must_haves:
  truths:
    - "UndoManager tracks undo/redo stacks with history limit"
    - "Operations coalesce when typed rapidly (1s timeout)"
    - "Undo reverses last operation, restores cursor/anchor"
    - "Redo reapplies undone operation"
  artifacts:
    - path: "undo.v"
      provides: "UndoManager, UndoOperation, undo/redo API"
      exports: ["UndoManager", "UndoOperation", "OperationType"]
      min_lines: 150
  key_links:
    - from: "undo.v"
      to: "layout_mutation.v"
      via: "MutationResult fields"
      pattern: "deleted_text|range_start|range_end|cursor_pos"
---

<objective>
Create core undo/redo infrastructure for text editing operations.

Purpose: Enable users to revert (Cmd+Z) and reapply (Cmd+Shift+Z) text mutations with proper
coalescing and history limits per UNDO-01, UNDO-02, UNDO-03 requirements.

Output: `undo.v` module with UndoManager struct and complete undo/redo API.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-undo-redo/14-RESEARCH.md
@.planning/phases/13-text-mutation/13-01-SUMMARY.md
@layout_mutation.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UndoOperation and UndoManager structs</name>
  <files>undo.v</files>
  <action>
Create `undo.v` in project root (same level as layout_mutation.v) with:

1. **OperationType enum:**
   ```v
   pub enum OperationType {
       insert
       delete
       replace
   }
   ```

2. **UndoOperation struct** storing inverse operation data:
   - op_type: OperationType
   - range_start, range_end: int (affected range in original text)
   - deleted_text, inserted_text: string (for inverse)
   - cursor_before, cursor_after: int
   - anchor_before, anchor_after: int

3. **UndoManager struct** with:
   - undo_stack: []UndoOperation (use array, not datatypes.Stack - easier for history trim)
   - redo_stack: []UndoOperation
   - max_history: int = 100 (UNDO-03 requirement)
   - last_mutation_time: i64 (for coalescing)
   - coalesce_timeout_ms: i64 = 1000 (1 second)
   - coalescable_op: ?UndoOperation (pending operation)

4. **new_undo_manager(max_history int) UndoManager** factory function

Use `import time` for timestamp operations.
Do NOT use datatypes.Stack - arrays are simpler for history limit enforcement.
  </action>
  <verify>
`v fmt -w undo.v && v -check-syntax undo.v` passes with no errors
  </verify>
  <done>
UndoManager and UndoOperation structs exist with proper fields for command pattern undo.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement undo/redo/coalesce methods</name>
  <files>undo.v</files>
  <action>
Add these methods to UndoManager:

1. **mutation_to_undo_op** - Convert MutationResult to UndoOperation:
   ```v
   pub fn mutation_to_undo_op(result MutationResult, inserted string,
                              cursor_before int, anchor_before int) UndoOperation
   ```
   - Determine op_type from result.deleted_text.len and inserted.len
   - Store all fields for inverse operation

2. **should_coalesce** - Check if new operation should merge with pending:
   ```v
   fn (um &UndoManager) should_coalesce(new_op UndoOperation, now i64) bool
   ```
   - Return false if no coalescable_op
   - Return false if timeout exceeded (now - last_mutation_time > coalesce_timeout_ms)
   - Return false if op_type differs
   - For insert: check range adjacency (new_op.range_start == coalescable.range_end)
   - For delete: check adjacency (new_op.range_end == coalescable.range_start)
   - Replace operations never coalesce

3. **coalesce_operation** - Merge new operation into pending:
   ```v
   fn (mut um UndoManager) coalesce_operation(new_op UndoOperation)
   ```
   - For insert: append inserted_text, update range_end, cursor_after, anchor_after
   - For delete: prepend deleted_text, update range_start, cursor_after, anchor_after

4. **record_mutation** - Main entry point for tracking mutations:
   ```v
   pub fn (mut um UndoManager) record_mutation(result MutationResult, inserted string,
                                               cursor_before int, anchor_before int)
   ```
   - Create UndoOperation via mutation_to_undo_op
   - If should_coalesce: call coalesce_operation
   - Else: flush pending coalescable_op to undo_stack, start new coalescable_op
   - Clear redo_stack on new operation

5. **flush_pending** - Push pending coalescable_op to stack:
   ```v
   pub fn (mut um UndoManager) flush_pending()
   ```
   - If coalescable_op exists, push to undo_stack and set to none
   - Enforce max_history (remove oldest if at limit)

6. **undo** - Pop from undo, apply inverse, push to redo:
   ```v
   pub fn (mut um UndoManager) undo(text string, cursor int, anchor int) ?(string, int, int)
   ```
   - Flush pending first
   - Return none if undo_stack empty
   - Pop operation, apply inverse mutation:
     - insert -> delete the inserted_text
     - delete -> reinsert deleted_text
     - replace -> remove inserted, restore deleted
   - Return (new_text, cursor_before, anchor_before)
   - Push to redo_stack

7. **redo** - Pop from redo, reapply operation, push to undo:
   ```v
   pub fn (mut um UndoManager) redo(text string, cursor int, anchor int) ?(string, int, int)
   ```
   - Return none if redo_stack empty
   - Pop operation, reapply original mutation:
     - insert -> insert the text
     - delete -> delete the text
     - replace -> delete old, insert new
   - Return (new_text, cursor_after, anchor_after)
   - Push to undo_stack

Use strings.Builder for all string mutations (O(n) vs O(n^2)).
  </action>
  <verify>
`v fmt -w undo.v && v -check-syntax undo.v` passes with no errors
  </verify>
  <done>
UndoManager has complete undo/redo API: record_mutation, undo, redo, flush_pending, with proper
coalescing and history limit enforcement.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add navigation break helper</name>
  <files>undo.v</files>
  <action>
Add helper for breaking coalescing on navigation:

1. **break_coalescing** - Flush pending when user navigates:
   ```v
   pub fn (mut um UndoManager) break_coalescing()
   ```
   - Simply calls flush_pending()
   - Named explicitly for semantic clarity at call sites

2. **can_undo** and **can_redo** - Check stack state:
   ```v
   pub fn (um &UndoManager) can_undo() bool
   pub fn (um &UndoManager) can_redo() bool
   ```
   - can_undo: coalescable_op exists OR undo_stack.len > 0
   - can_redo: redo_stack.len > 0

3. **clear** - Reset all state:
   ```v
   pub fn (mut um UndoManager) clear()
   ```
   - Empty both stacks, set coalescable_op to none
  </action>
  <verify>
`v fmt -w undo.v && v -check-syntax undo.v` passes
  </verify>
  <done>
UndoManager has helper methods for navigation breaks, state queries, and reset.
  </done>
</task>

</tasks>

<verification>
1. `v fmt -w undo.v` - formatting passes
2. `v -check-syntax undo.v` - no syntax errors
3. File exists at project root level
4. UndoManager has: undo, redo, record_mutation, flush_pending, break_coalescing, can_undo, can_redo
5. History limit enforced (max_history field, trimming logic)
6. Coalescing implemented (timeout, adjacency checks)
</verification>

<success_criteria>
- undo.v created with ~150-200 lines
- UndoManager struct with dual stacks, coalescing state
- UndoOperation captures all inverse operation data
- undo() reverses operation, returns restored state
- redo() reapplies operation, returns forward state
- record_mutation() handles coalescing automatically
- History limit enforced (oldest dropped at max)
</success_criteria>

<output>
After completion, create `.planning/phases/14-undo-redo/14-01-SUMMARY.md`
</output>
