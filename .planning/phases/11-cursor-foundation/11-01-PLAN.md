---
phase: 11-cursor-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - c_bindings.v
  - layout_types.v
  - layout.v
  - layout_query.v
autonomous: true

must_haves:
  truths:
    - "Layout.get_cursor_pos(byte_index) returns x, y, height for any valid index"
    - "LogAttr data cached in Layout during build (no PangoLayout recreation needed)"
    - "Cursor position handles end-of-text (index == text.len)"
  artifacts:
    - path: "c_bindings.v"
      provides: "PangoLogAttr struct and cursor API bindings"
      contains: "pango_layout_get_cursor_pos"
    - path: "layout_types.v"
      provides: "CursorPosition and LogAttr structs"
      contains: "struct CursorPosition"
    - path: "layout_query.v"
      provides: "get_cursor_pos method on Layout"
      contains: "pub fn (l Layout) get_cursor_pos"
    - path: "layout.v"
      provides: "LogAttr extraction during layout build"
      contains: "extract_log_attrs"
  key_links:
    - from: "layout.v"
      to: "c_bindings.v"
      via: "C.pango_layout_get_log_attrs_readonly call"
      pattern: "pango_layout_get_log_attrs_readonly"
    - from: "layout_query.v"
      to: "layout_types.v"
      via: "CursorPosition return type"
      pattern: "CursorPosition"
---

<objective>
Add Pango cursor bindings and CursorPosition geometry API to Layout.

Purpose: Enable cursor rendering by providing (x, y, height) geometry for any byte index.
Output: `Layout.get_cursor_pos(int) ?CursorPosition` method + LogAttr caching in Layout.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-cursor-foundation/11-RESEARCH.md
@c_bindings.v
@layout_types.v
@layout.v
@layout_query.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Pango cursor bindings and LogAttr struct</name>
  <files>c_bindings.v, layout_types.v</files>
  <action>
Add to c_bindings.v:

1. PangoLogAttr struct (bitfield packed as u32):
```v
@[typedef]
pub struct C.PangoLogAttr {
pub:
    flags u32  // Bitfields packed - use constants to extract
}
```

2. Bit flag constants for LogAttr extraction:
```v
pub const pango_log_attr_is_line_break = 0x01          // bit 0
pub const pango_log_attr_is_mandatory_break = 0x02    // bit 1
pub const pango_log_attr_is_char_break = 0x04         // bit 2
pub const pango_log_attr_is_white = 0x08              // bit 3
pub const pango_log_attr_is_cursor_position = 0x10    // bit 4
pub const pango_log_attr_is_word_start = 0x20         // bit 5
pub const pango_log_attr_is_word_end = 0x40           // bit 6
```

3. Pango cursor function bindings:
```v
fn C.pango_layout_get_cursor_pos(&C.PangoLayout, int, &C.PangoRectangle, &C.PangoRectangle)
fn C.pango_layout_move_cursor_visually(&C.PangoLayout, bool, int, int, int, &int, &int)
fn C.pango_layout_get_log_attrs_readonly(&C.PangoLayout, &int) &C.PangoLogAttr
```

Add to layout_types.v:

1. CursorPosition struct:
```v
pub struct CursorPosition {
pub:
    x      f32
    y      f32
    height f32
}
```

2. LogAttr struct (V-friendly version):
```v
pub struct LogAttr {
pub:
    is_cursor_position bool
    is_word_start      bool
    is_word_end        bool
    is_line_break      bool
}
```

3. Add `log_attrs []LogAttr` field to Layout struct.
  </action>
  <verify>
Run `v -check-syntax c_bindings.v` and `v -check-syntax layout_types.v` - both pass.
  </verify>
  <done>
PangoLogAttr binding exists with flag constants. CursorPosition and LogAttr structs defined.
Layout struct has log_attrs field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract LogAttr during layout build</name>
  <files>layout.v</files>
  <action>
Add extract_log_attrs function in layout.v:

```v
// extract_log_attrs extracts cursor/word boundary information from PangoLayout.
// Returns array with len = text.len + 1 (position before each char + end position).
fn extract_log_attrs(layout &C.PangoLayout, text_len int) []LogAttr {
    mut n_attrs := int(0)
    attrs_ptr := C.pango_layout_get_log_attrs_readonly(layout, &n_attrs)
    if attrs_ptr == unsafe { nil } || n_attrs == 0 {
        return []LogAttr{}
    }

    mut attrs := []LogAttr{cap: n_attrs}
    for i in 0 .. n_attrs {
        pango_attr := unsafe { attrs_ptr[i] }
        attrs << LogAttr{
            is_cursor_position: (pango_attr.flags & pango_log_attr_is_cursor_position) != 0
            is_word_start:      (pango_attr.flags & pango_log_attr_is_word_start) != 0
            is_word_end:        (pango_attr.flags & pango_log_attr_is_word_end) != 0
            is_line_break:      (pango_attr.flags & pango_log_attr_is_line_break) != 0
        }
    }
    return attrs
}
```

Modify build_layout_from_pango to call extract_log_attrs and populate Layout.log_attrs:
- Call `log_attrs := extract_log_attrs(layout, text.len)` before returning
- Add `log_attrs: log_attrs` to the returned Layout struct

NOTE: The PangoLayout pointer is valid at this point (before g_object_unref in caller).
  </action>
  <verify>
Run `v -check-syntax layout.v` - passes. Build with `v .` in project root - compiles.
  </verify>
  <done>
LogAttr extraction happens during layout build. Layout.log_attrs populated automatically.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add get_cursor_pos method to Layout</name>
  <files>layout_query.v</files>
  <action>
Add get_cursor_pos method to layout_query.v:

```v
// get_cursor_pos returns the geometry for rendering a cursor at the given byte index.
// Returns none if index is out of bounds.
//
// Algorithm:
// 1. Check bounds (0 <= byte_index <= text length via log_attrs.len - 1)
// 2. Try exact char_rect lookup for index
// 3. If at line end, use line rect right edge
// 4. Return x (left edge of char or line end), y (line top), height (line height)
//
// Note: This uses cached char_rects/lines. For precise bidi cursor positioning,
// a future version could store cursor_pos during layout build from Pango.
pub fn (l Layout) get_cursor_pos(byte_index int) ?CursorPosition {
    // Bounds check using log_attrs (len = text_len + 1)
    if l.log_attrs.len == 0 {
        return none
    }
    max_index := l.log_attrs.len - 1
    if byte_index < 0 || byte_index > max_index {
        return none
    }

    // Try exact char rect lookup
    if rect := l.get_char_rect(byte_index) {
        return CursorPosition{
            x:      rect.x
            y:      rect.y
            height: rect.height
        }
    }

    // Fallback: find containing line
    for line in l.lines {
        line_end := line.start_index + line.length
        if byte_index >= line.start_index && byte_index <= line_end {
            if byte_index == line_end {
                // At end of line - cursor at right edge
                return CursorPosition{
                    x:      line.rect.x + line.rect.width
                    y:      line.rect.y
                    height: line.rect.height
                }
            }
            // At start of line
            return CursorPosition{
                x:      line.rect.x
                y:      line.rect.y
                height: line.rect.height
            }
        }
    }

    // Ultimate fallback: use first line if exists
    if l.lines.len > 0 {
        first_line := l.lines[0]
        return CursorPosition{
            x:      first_line.rect.x
            y:      first_line.rect.y
            height: first_line.rect.height
        }
    }

    return none
}
```
  </action>
  <verify>
Run `v -check-syntax layout_query.v` - passes.
Run `v fmt -w layout_query.v` - formats correctly.
Build with `v .` - compiles.
  </verify>
  <done>
Layout.get_cursor_pos(int) returns CursorPosition with x, y, height for valid indices.
Handles end-of-text, end-of-line, and fallback cases.
  </done>
</task>

</tasks>

<verification>
1. Build project: `v .` compiles without errors
2. Run existing tests: `v test .` passes (if tests exist)
3. Verify LogAttr extraction works by running editor_demo and checking layout has log_attrs
4. Quick manual test: Layout with "Hello" should have log_attrs.len == 6 (5 chars + end)
</verification>

<success_criteria>
- CursorPosition struct defined with x, y, height fields
- LogAttr struct defined with cursor/word boundary flags
- Layout.log_attrs populated during layout build
- Layout.get_cursor_pos(byte_index) returns geometry for valid indices
- Returns none for out-of-bounds indices
- Project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/11-cursor-foundation/11-01-SUMMARY.md`
</output>
