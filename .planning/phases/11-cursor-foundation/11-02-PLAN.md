---
phase: 11-cursor-foundation
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - layout_query.v
  - examples/editor_demo.v
autonomous: false

must_haves:
  truths:
    - "Arrow keys move cursor by grapheme cluster (respects emoji/combining marks)"
    - "Cmd+Arrow moves cursor by word boundary"
    - "Home/End moves cursor to line start/end"
    - "Up/Down moves cursor to previous/next line at similar x position"
    - "Editor demo responds to keyboard navigation"
  artifacts:
    - path: "layout_query.v"
      provides: "Cursor movement methods"
      exports: ["move_cursor_left", "move_cursor_right", "move_cursor_word_left", "move_cursor_word_right", "move_cursor_line_start", "move_cursor_line_end", "move_cursor_up", "move_cursor_down"]
    - path: "examples/editor_demo.v"
      provides: "Keyboard navigation demo"
      contains: "key_down"
  key_links:
    - from: "layout_query.v"
      to: "layout_types.v"
      via: "LogAttr scanning for movement"
      pattern: "is_cursor_position"
    - from: "examples/editor_demo.v"
      to: "layout_query.v"
      via: "cursor movement API calls"
      pattern: "move_cursor"
---

<objective>
Add cursor movement APIs and keyboard navigation to editor demo.

Purpose: Enable arrow key, word, and line navigation with grapheme cluster respect.
Output: 8 cursor movement methods + editor demo with full keyboard navigation.
</objective>

<execution_context>
@/Users/mike/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-cursor-foundation/11-RESEARCH.md
@.planning/phases/11-cursor-foundation/11-01-SUMMARY.md
@layout_query.v
@layout_types.v
@examples/editor_demo.v
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add character-level cursor movement methods</name>
  <files>layout_query.v</files>
  <action>
Add cursor movement methods to layout_query.v that scan log_attrs for valid cursor positions:

```v
// move_cursor_left returns the byte index of the previous valid cursor position.
// Returns current index if already at start. Respects grapheme clusters (won't land inside emoji).
pub fn (l Layout) move_cursor_left(byte_index int) int {
    if byte_index <= 0 || l.log_attrs.len == 0 {
        return 0
    }
    // Scan backwards for previous is_cursor_position
    for i := byte_index - 1; i >= 0; i-- {
        if i < l.log_attrs.len && l.log_attrs[i].is_cursor_position {
            return i
        }
    }
    return 0
}

// move_cursor_right returns the byte index of the next valid cursor position.
// Returns current index if already at end. Respects grapheme clusters.
pub fn (l Layout) move_cursor_right(byte_index int) int {
    if l.log_attrs.len == 0 {
        return byte_index
    }
    max_index := l.log_attrs.len - 1
    if byte_index >= max_index {
        return max_index
    }
    // Scan forward for next is_cursor_position
    for i in (byte_index + 1) .. l.log_attrs.len {
        if l.log_attrs[i].is_cursor_position {
            return i
        }
    }
    return max_index
}

// move_cursor_word_left returns the byte index of the previous word start.
// Skips to word boundary, not just cursor position.
pub fn (l Layout) move_cursor_word_left(byte_index int) int {
    if byte_index <= 0 || l.log_attrs.len == 0 {
        return 0
    }
    // First move left to skip current position
    mut idx := byte_index - 1
    // Skip any whitespace/non-word chars
    for idx > 0 && !l.log_attrs[idx].is_word_start {
        idx--
    }
    // If we found a word start, return it
    if idx >= 0 && l.log_attrs[idx].is_word_start {
        return idx
    }
    return 0
}

// move_cursor_word_right returns the byte index of the next word start.
pub fn (l Layout) move_cursor_word_right(byte_index int) int {
    if l.log_attrs.len == 0 {
        return byte_index
    }
    max_index := l.log_attrs.len - 1
    if byte_index >= max_index {
        return max_index
    }
    // Scan forward for next word start
    for i in (byte_index + 1) .. l.log_attrs.len {
        if l.log_attrs[i].is_word_start {
            return i
        }
    }
    return max_index
}
```
  </action>
  <verify>
Run `v -check-syntax layout_query.v` - passes.
Run `v fmt -w layout_query.v` - formats correctly.
  </verify>
  <done>
move_cursor_left, move_cursor_right, move_cursor_word_left, move_cursor_word_right methods added.
All respect grapheme clusters via is_cursor_position/is_word_start scanning.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add line-level cursor movement methods</name>
  <files>layout_query.v</files>
  <action>
Add line navigation methods to layout_query.v:

```v
// move_cursor_line_start returns the byte index of the start of the current line.
pub fn (l Layout) move_cursor_line_start(byte_index int) int {
    for line in l.lines {
        line_end := line.start_index + line.length
        if byte_index >= line.start_index && byte_index <= line_end {
            return line.start_index
        }
    }
    // Fallback: return 0
    return 0
}

// move_cursor_line_end returns the byte index of the end of the current line.
pub fn (l Layout) move_cursor_line_end(byte_index int) int {
    for line in l.lines {
        line_end := line.start_index + line.length
        if byte_index >= line.start_index && byte_index <= line_end {
            return line_end
        }
    }
    // Fallback: return max index
    if l.log_attrs.len > 0 {
        return l.log_attrs.len - 1
    }
    return 0
}

// move_cursor_up returns byte index on previous line at similar x position.
// preferred_x is the x coordinate to try to maintain (pass -1 to use cursor's current x).
pub fn (l Layout) move_cursor_up(byte_index int, preferred_x f32) int {
    if l.lines.len == 0 {
        return byte_index
    }

    // Find current line index
    mut current_line_idx := -1
    mut target_x := preferred_x
    for i, line in l.lines {
        line_end := line.start_index + line.length
        if byte_index >= line.start_index && byte_index <= line_end {
            current_line_idx = i
            // If no preferred_x, use current cursor x
            if target_x < 0 {
                if pos := l.get_cursor_pos(byte_index) {
                    target_x = pos.x
                } else {
                    target_x = line.rect.x
                }
            }
            break
        }
    }

    if current_line_idx <= 0 {
        // Already on first line or not found
        return byte_index
    }

    // Find closest char on previous line
    prev_line := l.lines[current_line_idx - 1]
    return l.find_closest_index_in_line(prev_line, target_x)
}

// move_cursor_down returns byte index on next line at similar x position.
pub fn (l Layout) move_cursor_down(byte_index int, preferred_x f32) int {
    if l.lines.len == 0 {
        return byte_index
    }

    // Find current line index
    mut current_line_idx := -1
    mut target_x := preferred_x
    for i, line in l.lines {
        line_end := line.start_index + line.length
        if byte_index >= line.start_index && byte_index <= line_end {
            current_line_idx = i
            if target_x < 0 {
                if pos := l.get_cursor_pos(byte_index) {
                    target_x = pos.x
                } else {
                    target_x = line.rect.x
                }
            }
            break
        }
    }

    if current_line_idx < 0 || current_line_idx >= l.lines.len - 1 {
        // Not found or already on last line
        return byte_index
    }

    // Find closest char on next line
    next_line := l.lines[current_line_idx + 1]
    return l.find_closest_index_in_line(next_line, target_x)
}

// find_closest_index_in_line returns the byte index closest to target_x within the given line.
fn (l Layout) find_closest_index_in_line(line Line, target_x f32) int {
    line_end := line.start_index + line.length
    mut closest_idx := line.start_index
    mut min_dist := f32(1e9)

    for i in line.start_index .. line_end {
        rect_idx := l.char_rect_by_index[i] or { continue }
        cr := l.char_rects[rect_idx]
        char_mid_x := cr.rect.x + cr.rect.width / 2
        dist := math.abs(target_x - char_mid_x)
        if dist < min_dist {
            min_dist = dist
            closest_idx = i
        }
    }

    // Check if closer to end of line
    end_x := line.rect.x + line.rect.width
    if math.abs(target_x - end_x) < min_dist {
        return line_end
    }

    return closest_idx
}
```

NOTE: Import `math` at top of layout_query.v if not already imported (should be there from existing code).
  </action>
  <verify>
Run `v -check-syntax layout_query.v` - passes.
Run `v fmt -w layout_query.v` - formats correctly.
Build with `v .` - compiles.
  </verify>
  <done>
move_cursor_line_start, move_cursor_line_end, move_cursor_up, move_cursor_down methods added.
Up/down methods support preferred_x for vertical navigation stability.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add keyboard navigation to editor demo</name>
  <files>examples/editor_demo.v</files>
  <action>
Update editor_demo.v to handle keyboard events:

1. Add preferred_x field to EditorApp for up/down navigation:
```v
struct EditorApp {
mut:
    // ... existing fields ...
    preferred_x  f32  // Remembered x position for up/down navigation
}
```

2. Add key_down event handling in the event function. Expand the match statement:
```v
.key_down {
    // Handle navigation keys
    cmd_held := e.modifiers.super  // macOS Cmd key

    match e.key_code {
        .left {
            if cmd_held {
                app.cursor_idx = app.layout.move_cursor_word_left(app.cursor_idx)
            } else {
                app.cursor_idx = app.layout.move_cursor_left(app.cursor_idx)
            }
            app.preferred_x = -1  // Reset preferred x on horizontal movement
        }
        .right {
            if cmd_held {
                app.cursor_idx = app.layout.move_cursor_word_right(app.cursor_idx)
            } else {
                app.cursor_idx = app.layout.move_cursor_right(app.cursor_idx)
            }
            app.preferred_x = -1
        }
        .up {
            if app.preferred_x < 0 {
                if pos := app.layout.get_cursor_pos(app.cursor_idx) {
                    app.preferred_x = pos.x
                }
            }
            app.cursor_idx = app.layout.move_cursor_up(app.cursor_idx, app.preferred_x)
        }
        .down {
            if app.preferred_x < 0 {
                if pos := app.layout.get_cursor_pos(app.cursor_idx) {
                    app.preferred_x = pos.x
                }
            }
            app.cursor_idx = app.layout.move_cursor_down(app.cursor_idx, app.preferred_x)
        }
        .home {
            app.cursor_idx = app.layout.move_cursor_line_start(app.cursor_idx)
            app.preferred_x = -1
        }
        .end {
            app.cursor_idx = app.layout.move_cursor_line_end(app.cursor_idx)
            app.preferred_x = -1
        }
        else {}
    }
    // Clear selection on navigation (unless shift held - future feature)
    app.select_start = -1
}
```

3. Update cursor drawing to use get_cursor_pos instead of manual lookup:
Replace the manual cursor position calculation with:
```v
// Draw Cursor using get_cursor_pos API
if pos := app.layout.get_cursor_pos(app.cursor_idx) {
    app.gg.draw_rect_filled(offset_x + pos.x, offset_y + pos.y, 2, pos.height, gg.red)
}
```

4. Add emoji and combining marks to test text to verify grapheme cluster handling:
Update the text constant to include test cases:
```v
text: 'Hello VGlyph Editor!\n\n' +
    'This is a demo of cursor positioning and keyboard navigation.\n\n' +
    'Try arrow keys (Cmd+Arrow for words, Home/End for line).\n\n' +
    'Grapheme tests: flag: hello  family:  rainbow: \n' +
    'Arabic: مرحبا  Hebrew: שלום\n' +
    'Combined: e + combining accent: e\u0301'
```

5. Initialize preferred_x to -1 in EditorApp initialization.
  </action>
  <verify>
Run `v fmt -w examples/editor_demo.v` - formats correctly.
Build demo: `v examples/editor_demo.v` - compiles.
Run demo and test keyboard navigation.
  </verify>
  <done>
Editor demo handles arrow keys, Cmd+Arrow, Home/End.
Cursor drawn using get_cursor_pos API.
Test text includes emoji and combining marks for grapheme verification.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete cursor foundation: geometry API + 8 movement methods + keyboard navigation demo.
  </what-built>
  <how-to-verify>
1. Build and run: `v run examples/editor_demo.v`
2. Click anywhere in text - cursor appears at click position
3. Press Left/Right arrows - cursor moves by character (should skip over emoji as single unit)
4. Press Cmd+Left/Right - cursor jumps by word
5. Press Home/End - cursor jumps to line start/end
6. Press Up/Down - cursor moves to adjacent line at similar x position
7. Navigate through the emoji line - cursor should NOT land inside flag/family emoji
8. Navigate through Arabic text - verify cursor doesn't break text visually
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. Build project: `v .` compiles without errors
2. Run existing tests: `v test .` passes
3. Run editor demo: `v run examples/editor_demo.v`
4. Verify all keyboard shortcuts work:
   - Left/Right: character movement
   - Cmd+Left/Right: word movement
   - Home/End: line movement
   - Up/Down: vertical navigation
5. Verify grapheme clusters respected (emoji navigation)
</verification>

<success_criteria>
- 8 cursor movement methods implemented (left, right, word_left, word_right, line_start, line_end, up, down)
- All methods respect grapheme clusters via LogAttr scanning
- Editor demo has full keyboard navigation
- Cursor rendering uses get_cursor_pos API
- Emoji and combining marks navigate correctly (no landing inside clusters)
- Requirements CURS-01 through CURS-05 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/11-cursor-foundation/11-02-SUMMARY.md`
</output>
